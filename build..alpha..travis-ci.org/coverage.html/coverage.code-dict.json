{"/home/travis/build/npmtest/node-npmtest-svg-sprite/test.js":"/* istanbul instrument in package npmtest_svg_sprite */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/lib.npmtest_svg_sprite.js":"/* istanbul instrument in package npmtest_svg_sprite */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_svg_sprite = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_svg_sprite = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-svg-sprite && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_svg_sprite */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_svg_sprite\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_svg_sprite.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_svg_sprite.rollup.js'] =\n            local.assetsDict['/assets.npmtest_svg_sprite.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_svg_sprite.__dirname + '/lib.npmtest_svg_sprite.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE.txt\n */\n\nvar CONFIG\t\t\t\t\t= require('./svg-sprite/config');\nvar QUEUE\t\t\t\t\t= require('./svg-sprite/queue');\nvar SVGO\t\t\t\t\t= require('./svg-sprite/transform/svgo');\nvar LAYOUTER\t\t\t\t= require('./svg-sprite/layouter');\nvar _\t\t\t\t\t\t= require('lodash');\nvar pluck\t\t\t\t\t= require('lodash.pluck');\nvar path\t\t\t\t\t= require('path');\nvar File\t\t\t\t\t= require('vinyl');\nvar events\t\t\t\t\t= require('events');\nvar async\t\t\t\t\t= require('async');\nvar os \t\t\t\t\t\t= require('os');\nvar pretty\t\t\t\t\t= require('prettysize');\nvar util\t\t\t\t\t= require('util');\n\n/**\n * SVGSpriter class\n *\n * @param {Object} config\t\t\t\tConfiguration\n */\nfunction SVGSpriter(config) {\n\tthis.config\t\t\t\t= new CONFIG(config);\n\tthis._queue\t\t\t\t= new QUEUE(this);\n\tthis._shapes\t\t\t= [];\n\tthis._shapeTransformers\t= {svgo: SVGO};\n\tthis._compileQueue\t\t= [];\n\tthis._shapesDest\t\t= [];\n\n\tevents.EventEmitter.call(this);\n\n\tthis._queue.on('empty', this._compile.bind(this));\n\tthis._queue.on('empty', this._getShapes.bind(this));\n\tthis.on('compiled', this._compile.bind(this));\n\n\tthis.info('Created spriter instance');\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriter.prototype = Object.create(events.EventEmitter.prototype);\n\n/**\n * SVG shapes making up the sprites\n *\n * @type {Array}\n */\nSVGSpriter.prototype._shapes = [];\n\n/**\n * Namespace powers\n *\n * @type {Array}\n */\nSVGSpriter.prototype._namespacePow = [];\n\n/**\n * Add an SVG shape to the sprites\n *\n * @param {File|String} file\t\t\tVinyl file object or absolute file path\n * @param {String} name\t\t\t\t\tName part of the file path\n * @param {String} svg\t\t\t\t\tSVG content\n * @return {SVGSpriter}\t\t\t\t\tSelf reference\n * @throws {Error}\t\t\t\t\t\tIn case an invalid file should be added\n */\nSVGSpriter.prototype.add = function(file, name, svg) {\n\n\t// If no vinyl file object has been given\n\tif (!this._isVinylFile(file)) {\n\t\tfile\t\t\t\t= _.trim(file);\n\n\t\t// If the name part of the file path is absolute\n\t\tif (name && path.isAbsolute(name)) {\n\t\t\terror\t\t\t= util.format('SVGSpriter.add: \"%s\" is not a valid relative file name', name);\n\n\t\t// Else\n\t\t} else {\n\t\t\tname\t\t\t= _.trimStart(_.trim(name), path.sep + '.') || path.basename(file);\n\t\t\tsvg\t\t\t\t= _.trim(svg);\n\n\t\t\t// Argument validation\n\t\t\tvar error\t\t= null;\n\t\t\tif (arguments.length < 3) {\n\t\t\t\terror\t\t= 'SVGSpriter.add: You must provide 3 arguments';\n\t\t\t}\n\t\t\tif (!file.length) {\n\t\t\t\terror\t\t= util.format('SVGSpriter.add: \"%s\" is not a valid absolute file name', file);\n\t\t\t}\n\t\t\tif (!name.length) {\n\t\t\t\terror\t\t= util.format('SVGSpriter.add: \"%s\" is not a valid relative file name', name);\n\t\t\t}\n\t\t\tif (!svg.length) {\n\t\t\t\terror\t\t= 'SVGSpriter.add: You must provide SVG contents';\n\t\t\t}\n\t\t\tif (file.substr(-name.length) !== name) {\n\t\t\t\terror\t\t= util.format('SVGSpriter.add: \"%s\" is not the local part of \"%s\"', name, file);\n\t\t\t}\n\t\t}\n\n\t\t// In case of an error: Throw it!\n\t\tif (error) {\n\t\t\tvar e\t\t\t= new Error(error);\n\t\t\te.name\t\t\t= 'ArgumentError';\n\t\t\te.errno\t\t\t= 1419945903;\n\t\t\tthis.error(error, e);\n\t\t\tthrow e;\n\t\t}\n\n\t\t// Instanciate a vinyl file\n\t\tfile\t\t\t= new File({\n\t\t\tbase\t\t: file.substring(0, file.length - name.length),\n\t\t\tpath\t\t: file,\n\t\t\tcontents\t: new Buffer(svg)\n\t\t});\n\t}\n\n\tfile.base\t\t\t= path.resolve(file.base);\n\n\t// Add the shape to the internal processing queue\n\tthis._queue.add(file);\n\n\treturn this;\n};\n\n/**\n * Duck-typing check for vinyl file objects\n *\n * This check is necessary as singletons don't work cross-module and `instanceof` fails in these situations.\n *\n * @param {Mixed} file\t\t\t\t\tArbitrary parameter\n * @return {Boolean}\t\t\t\t\tParameter is a vinyl file object\n */\nSVGSpriter.prototype._isVinylFile = function(file) {\n\treturn _.isObject(file) && ((file instanceof File) || ((file.constructor.name === 'File') && (['path', 'contents', 'relative'].filter(function(property){ return property in this; }, file).length === 3)));\n};\n\n/**\n * Transform a single shape\n *\n * @param {SVGShape} shape\t\t\t\tShape\n * @param {Function} cb\t\t\t\t\tCallback\n */\nSVGSpriter.prototype._transformShape = function(shape, cb) {\n\tvar tasks\t\t\t\t\t= [],\n\tthat\t\t\t\t\t\t= this,\n\tcreateTransformTask\t\t\t= function(transform){\n\n\t\t// If it's a custom transformer\n\t\tif (_.isFunction(transform[1])) {\n\t\t\treturn function() {\n\t\t\t\ttransform[1](shape, that, arguments[arguments.length - 1]);\n\t\t\t};\n\n\t\t// Else if it's a registered transformer\n\t\t} else if ((transform[0] in that._shapeTransformers) && _.isObject(transform[1])) {\n\t\t\treturn function() {\n\t\t\t\tthat._shapeTransformers[transform[0]](shape, transform[1], that, arguments[arguments.length - 1]);\n\t\t\t};\n\n\t\t// Else: Break\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\n\t};\n\n\t// Run through all configured transforms\n\tfor (var t = 0, task; t < this.config.shape.transform.length; ++t) {\n\t\ttask\t\t\t\t\t= createTransformTask(this.config.shape.transform[t]);\n\n\t\tif (task) {\n\t\t\ttasks.push(task);\n\t\t}\n\t}\n\n\tasync.waterfall(tasks, function(error){\n\t\tcb(error);\n\t});\n};\n\n/**\n * Compile the sprite & additional resources\n *\n * @param {Object} config\t\t\t\tConfiguration\n * @param {Function} cb\t\t\t\t\tCallback\n */\nSVGSpriter.prototype.compile = function() {\n\tvar args\t\t\t\t\t= _.toArray(arguments),\n\tconfig\t\t\t\t\t\t= _.isPlainObject(args[0]) ? this.config.filter(args.shift()) : _.clone(this.config.mode, true),\n\tcb\t\t\t\t\t\t\t= _.isFunction(args[0]) ? args.shift() : function(error){ throw error; };\n\n\t// Schedule a compilation run\n\tthis._compileQueue.push([config, cb]);\n\tthis._compile();\n};\n\n/**\n * Run the next compile task\n */\nSVGSpriter.prototype._compile = function() {\n\n\t// If the shape queue is not currently active\n\tif (!this._queue.active && this._compileQueue.length) {\n\t\tvar that \t\t\t\t= this;\n\t\tvar args\t\t\t\t= this._compileQueue.shift();\n\n\t\t// If this is a modeless run\n\t\tif (args[0] === {}) {\n\t\t\tvar files\t\t\t= {};\n\n\t\t\t// Add intermediate SVG files\n\t\t\tif (that.config.shape.dest) {\n\t\t\t\tfiles.shapes\t= that._getShapeFiles(that.config.shape.dest);\n\t\t\t\tthat.verbose('Returning %d intermediate SVG files', files.shapes.length);\n\t\t\t}\n\n\t\t\tthat._logStats(files);\n\t\t\targs[1](null, files, {});\n\n\t\t// Else\n\t\t} else {\n\t\t\tvar masterShapes\t\t= _.reject(this._shapes, function(shape) { return !!shape.master; }).length;\n\t\t\tthis.info('Compiling %d shapes ...', masterShapes);\n\n\t\t\t// Initialize the namespace powers\n\t\t\twhile (!this._namespacePow.length || (Math.pow(26, this._namespacePow.length) < masterShapes)) {\n\t\t\t\tthis._namespacePow.unshift(Math.pow(26, this._namespacePow.length));\n\t\t\t\t_.invoke(this._shapes, 'resetNamespace');\n\t\t\t}\n\n\t\t\t// Sort shapes by ID\n\t\t\tthis._shapes\t\t\t= this._shapes.sort(this.config.shape.sort);\n\n\t\t\t// Set the shape namespaces on all master shapes\n\t\t\t_.reject(this._shapes, function(shape) { return !!shape.master; }).map(function(shape, index){\n\t\t\t\tshape.setNamespace(this._indexNamespace(index));\n\t\t\t}, this);\n\n\t\t\tthis._layout(args[0], function(error, files, data) {\n\n\t\t\t\t// Add intermediate SVG files\n\t\t\t\tif (that.config.shape.dest) {\n\t\t\t\t\tfiles.shapes\t= that._getShapeFiles(that.config.shape.dest);\n\t\t\t\t\tthat.verbose('Returning %d intermediate SVG files', files.shapes.length);\n\t\t\t\t}\n\t\t\t\tthat.info('Finished %s sprite compilation', _.keys(data).map(function(mode){\n\t\t\t\t\treturn '«' + mode + '»';\n\t\t\t\t}).join(' + '));\n\n\t\t\t\tthat._logStats(files);\n\n\t\t\t\targs[1](error, files, data);\n\t\t\t\tthat.emit('compiled');\n\t\t\t});\n\t\t}\n\t}\n};\n\n/**\n * Return a unique namespace prefix for a shape index\n *\n * @param {Number} index\t\tShape index\n * @return {String}\t\t\t\tNamespace prefix\n */\nSVGSpriter.prototype._indexNamespace = function(index) {\n\tfor (var ns = '', n = 0, c; n < this._namespacePow.length; ++n) {\n\t\tc\t\t\t\t\t\t= Math.floor(index / this._namespacePow[n]);\n\t\tns\t\t\t\t\t\t+= String.fromCharCode(97 + c);\n\t\tindex\t\t\t\t\t-= c * this._namespacePow[n];\n\t}\n\treturn ns;\n};\n\n/**\n * Layout the sprites\n *\n * @param {Object} config\t\tLayout configuration\n * @param {Function} cb\t\t\tCallback\n */\nSVGSpriter.prototype._layout = function(config, cb) {\n\tvar tasks\t\t\t\t\t= [],\n\tfiles\t\t\t\t\t\t= {},\n\tlayout\t\t\t\t\t\t= new LAYOUTER(this, config),\n\tcreateLayoutTask\t\t\t= function(k, m){\n\t\treturn function(_cb){\n\t\t\tlayout.layout(files, k, m, _cb);\n\t\t};\n\t};\n\n\tfor (var mode in config) {\n\t\ttasks.push(createLayoutTask(mode, config[mode].mode));\n\t}\n\n\tasync.parallelLimit(tasks, os.cpus().length * 2, function(error, data){\n\t\tcb(error, files, _.zipObject(pluck(data, 'key'), data));\n\t});\n};\n\n/**\n * Return all current shapes\n *\n * @param {String} dest\t\t\tDestination directory\n * @param {Function} cb\t\t\tCallback\n */\nSVGSpriter.prototype.getShapes = function(dest, cb) {\n\tthis._shapesDest.push([dest, cb]);\n\tthis._getShapes();\n};\n\n/**\n * Return all current shapes\n */\nSVGSpriter.prototype._getShapes = function() {\n\n\t// If the shape queue is not currently active\n\tif (!this._queue.active) {\n\t\twhile(this._shapesDest.length) {\n\t\t\tvar args = this._shapesDest.shift();\n\t\t\targs[1](null, this._getShapeFiles(args[0]));\n\t\t}\n\t}\n};\n\n/**\n * Return the shapes as a list of vinyl files\n *\n * @param {String} dest\t\t\tDestination directory\n * @return {Array}\t\t\t\tShape file list\n */\nSVGSpriter.prototype._getShapeFiles = function(dest) {\n\treturn this._shapes.map(function(shape) {\n\t\treturn new File({\n\t\t\tbase\t\t\t\t: this.config.dest,\n\t\t\tpath\t\t\t\t: path.join(dest, shape.id + '.svg'),\n\t\t\tcontents\t\t\t: new Buffer(shape.getSVG(false))\n\t\t});\n\t}, this);\n};\n\n/**\n * Log file statistics\n *\n * @param {Object} files\t\tFiles\n */\nSVGSpriter.prototype._logStats = function(files) {\n\tvar sizes\t\t\t\t\t= {},\n\texts\t\t\t\t\t\t= {};\n\tfor (var mode in files) {\n\t\tfor (var resource in files[mode]) {\n\t\t\tvar file\t\t\t= files[mode][resource].relative,\n\t\t\text\t\t\t\t\t= path.extname(files[mode][resource].path).toUpperCase();\n\t\t\texts[ext]\t\t\t= (exts[ext] || 0) + 1;\n\t\t\tsizes[file]\t\t\t= pretty(files[mode][resource].contents.length);\n\t\t}\n\t}\n\tthis.info('Created ' + _.toPairs(exts).map(function(ext){\n\t\treturn ext[1] + ' x ' + ext[0].substr(1);\n\t}).join(', '));\n\n\tObject.keys(sizes).sort().forEach(function(file){\n\t\tthis.verbose('Created %s: %s', file, sizes[file]);\n\t}, this);\n};\n\n/**\n * Pass info messages on to the logger\n */\nSVGSpriter.prototype.info = function() {\n\tthis.config.log.info.apply(this.config.log, arguments);\n};\n\n/**\n * Pass verbose messages on to the logger\n */\nSVGSpriter.prototype.verbose = function() {\n\tthis.config.log.verbose.apply(this.config.log, arguments);\n};\n\n/**\n * Pass debug messages on to the logger\n */\nSVGSpriter.prototype.debug = function() {\n\tthis.config.log.debug.apply(this.config.log, arguments);\n};\n\n/**\n * Pass error messages on to the logger\n */\nSVGSpriter.prototype.error = function() {\n\tthis.config.log.error.apply(this.config.log, arguments);\n};\n\n/**\n * Module export (constructor wrapper)\n *\n * @param {Object} config\t\tConfiguration\n * @return {SVGSpriter}\t\t\tSVGSpriter instance\n */\nmodule.exports = function(config) {\n\treturn new SVGSpriter(config || {});\n};\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/config.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _\t\t\t\t\t\t\t\t\t= require('lodash'),\n\tpath\t\t\t\t\t\t\t\t= require('path'),\n\tyaml\t\t\t\t\t\t\t\t= require('js-yaml'),\n\tfs\t\t\t\t\t\t\t\t\t= require('fs'),\n\twinston\t\t\t\t\t\t\t\t= require('winston'),\n\t/**\n\t * Sprite types\n\t *\n\t * @type {Array}\n\t */\n\tspriteTypes\t\t\t\t\t\t\t= ['css', 'view', 'defs', 'symbol', 'stack'],\n\t/**\n\t * List of default shape transformations\n\t *\n\t * @type {Array}\n\t */\n\tdefaultShapeTransform\t\t\t\t= ['svgo'],\n\t/**\n\t * Default SVG configuration\n\t *\n\t * @type {Object}\n\t */\n\tdefaultSVGConfig\t\t\t\t\t= {\n\t\t/**\n\t\t * Add a DOCTYPE declaration to SVG documents\n\t\t *\n\t\t * @type {Boolean\n\t\t */\n\t\tdoctypeDeclaration\t\t\t\t: true,\n\t\t/**\n\t\t * Add an XML declaration to SVG documents\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\txmlDeclaration\t\t\t\t\t: true,\n\t\t/**\n\t\t * Namespace IDs in SVG documents to avoid ID clashes\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tnamespaceIDs\t\t\t\t\t: true,\n\t\t/**\n\t\t * Namespace CSS class names in SVG documents to avoid CSS clashes\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tnamespaceClassnames\t      \t\t: true,\n\t\t/**\n\t\t * Add width and height attributes to the sprite SVG\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tdimensionAttributes\t\t\t\t: true,\n\t\t/**\n\t\t * Additional root attributes for the outermost <svg> element\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\trootAttributes\t\t\t\t    : {},\n\t\t/**\n\t\t * Floating point precision for CSS positioning values\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tprecision                       : -1\n\t};\n\n/**\n * SVGSpriter configuration\n *\n * @param {Object} config\t\t\t\tConfiguration\n */\nfunction SVGSpriterConfig(config) {\n\n\t// Logging\n\tthis.log\t\t\t\t\t\t\t= '';\n\tif ('log' in config){\n\t\tif ((config.log instanceof winston.Logger) || (_.isObject(config.log) && !_.isUndefined(config.log.level) && _.isObject(config.log.transports) && _.isFunction(config.log.log))) {\n\t\t\tthis.log\t\t\t\t\t= config.log;\n\t\t} else {\n\t\t\tthis.log\t\t\t\t\t= (_.isString(config.log) && (['info', 'verbose', 'debug'].indexOf(config.log) >= 0)) ? config.log : (config.log ? 'info' : '');\n\t\t}\n\t}\n\tif (_.isString(this.log)) {\n\t\tvar twoDigits\t\t\t\t\t= function(i) {\n\t\t\treturn ('0' + i).slice(-2);\n\t\t};\n\t\tthis.log\t\t\t\t\t\t= new winston.Logger({\n\t\t\ttransports\t\t\t\t\t: [new (winston.transports.Console)({\n\t\t\t\tlevel\t\t\t\t\t: this.log || 'info',\n\t\t\t\tsilent\t\t\t\t\t: !this.log.length,\n\t\t\t\tcolorize\t\t\t\t: true,\n\t\t\t\tprettyPrint\t\t\t\t: true,\n\t\t\t\ttimestamp\t\t\t\t: function() {\n\t\t\t\t\tvar now\t\t\t\t= new Date();\n\t\t\t\t\treturn now.getFullYear() + '-' + twoDigits(now.getMonth()) + '-' + twoDigits(now.getDate()) + ' ' + twoDigits(now.getHours()) + ':' + twoDigits(now.getMinutes()) + ':' + twoDigits(now.getSeconds());\n\t\t\t\t}\n\t\t\t})]\n\t\t});\n\t}\n\n\tthis.log.debug('Started logging');\n\n\tthis.dest\t\t\t\t\t\t\t= path.resolve(config.dest || '.');\n\n\tthis.log.debug('Prepared general options');\n\n\tthis.shape\t\t\t\t\t\t\t= ('shape' in config) ? _.assign({}, config.shape || {}) : {};\n\n\tvar stat, t, transforms = null;\n\n\t// Parse meta data (if configured)\n\tif (('meta' in this.shape) && !_.isPlainObject(this.shape.meta)) {\n\t\tvar meta\t\t\t\t\t\t= _.isString(this.shape.meta) ? path.resolve(this.shape.meta) : null,\n\t\tmetaFile\t\t\t\t\t\t= meta;\n\t\tstat\t\t\t\t\t\t\t= meta ? fs.lstatSync(meta) : null;\n\t\tthis.shape.meta\t\t\t\t\t= {};\n\t\tif (stat) {\n\t\t\tif (stat.isSymbolicLink()) {\n\t\t\t\tmeta\t\t\t\t\t= fs.readlinkSync(meta);\n\t\t\t\tstat\t\t\t\t\t= fs.statSync(meta);\n\t\t\t}\n\t\t\tmeta\t\t\t\t\t\t= stat.isFile() ? fs.readFileSync(meta, 'utf8') : null;\n\t\t\tmeta\t\t\t\t\t\t= meta ? yaml.safeLoad(meta) : {};\n\t\t\tfor (var m in meta) {\n\t\t\t\tif (_.isPlainObject(meta[m])) {\n\t\t\t\t\tthis.shape.meta[path.join(path.dirname(m), path.basename(m, '.svg'))] = _.pick(meta[m], ['title', 'description']);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.log.debug('Processed meta data file \"%s\"', path.basename(metaFile));\n\t\t}\n\t} else {\n\t\tthis.shape.meta\t\t\t\t\t= {};\n\t}\n\n\t// Parse alignment data (if configured)\n\tif (('align' in this.shape) && !_.isPlainObject(this.shape.align)) {\n\t\tvar align\t\t\t\t\t\t= _.isString(this.shape.align) ? path.resolve(this.shape.align) : null,\n\t\talignFile\t\t\t\t\t\t= align;\n\t\tstat\t\t\t\t\t\t\t= align ? fs.lstatSync(align) : null;\n\t\tthis.shape.align\t\t\t\t= {'*': {'%s': 0}};\n\t\tif (stat) {\n\t\t\tif (stat.isSymbolicLink()) {\n\t\t\t\talign\t\t\t\t\t= fs.readlinkSync(align);\n\t\t\t\tstat\t\t\t\t\t= fs.statSync(align);\n\t\t\t}\n\t\t\talign\t\t\t\t\t\t= stat.isFile() ? fs.readFileSync(align, 'utf8') : null;\n\t\t\talign\t\t\t\t\t\t= align ? yaml.safeLoad(align) : {};\n\t\t\tfor (var a in align) {\n\t\t\t\tif (_.isPlainObject(align[a]) && Object.keys(align[a]).length) {\n\t\t\t\t\tthis.shape.align[a]\t= this.shape.align[a] || {};\n\t\t\t\t\tfor (var tmpl in align[a]) {\n\t\t\t\t\t\tvar template\t= tmpl.length ? ((tmpl.indexOf('%s') >= 0) ? tmpl : ('%s' + tmpl)) : '%s';\n\t\t\t\t\t\tthis.shape.align[path.join(path.dirname(a), path.basename(a, '.svg'))][template] = Math.max(0, Math.min(1, parseFloat(align[a][tmpl], 10)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.log.debug('Processed alignment data file \"%s\"', path.basename(alignFile));\n\t\t}\n\t} else {\n\t\tthis.shape.align\t\t\t\t= {'*': {'%s': 0}};\n\t}\n\n\t// Register a sorting callback for shape names\n\tif (!('sort' in this.shape) || !_.isFunction(this.shape.sort)) {\n\t\tthis.shape.sort\t\t\t\t\t= function(shape1, shape2){\n\t\t\treturn (shape1.id === shape2.id) ? 0 : ((shape1.id > shape2.id) ? 1 : -1);\n\t\t};\n\t}\n\n\t// Intermediate SVG destination\n\tthis.shape.dest\t\t\t\t\t\t= ('dest' in this.shape) ? ('' + this.shape.dest).trim() : '';\n\tthis.shape.dest\t\t\t\t\t\t= this.shape.dest.length ? path.resolve(this.dest, this.shape.dest) : null;\n\n\t// Expand spacing options to arrays\n\tthis.shape.spacing\t\t\t\t\t= ('spacing' in this.shape) ? (this.shape.spacing || {}) : {};\n\t['padding'].forEach(function(property){\n\t\tvar spacing;\n\n\t\tif (!_.isArray(this.spacing[property])) {\n\t\t\tspacing\t\t\t\t\t\t= Math.max(0, parseInt(this.spacing[property] || 0, 10));\n\t\t\tthis.spacing[property]\t\t= {top: spacing, right: spacing, bottom: spacing, left: spacing};\n\t\t} else {\n\t\t\tspacing\t\t\t\t\t\t= this.spacing[property].map(function(n){ return Math.max(0, n); });\n\t\t\tswitch(spacing.length) {\n\t\t\t\tcase 1:\n\t\t\t\t\tspacing\t\t\t\t= {top: spacing[0], right: spacing[0], bottom: spacing[0], left: spacing[0]};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tspacing\t\t\t\t= {top: spacing[0], right: spacing[1], bottom: spacing[0], left: spacing[1]};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tspacing\t\t\t\t= {top: spacing[0], right: spacing[1], bottom: spacing[2], left: spacing[1]};\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tspacing\t\t\t\t= {top: spacing[0], right: spacing[1], bottom: spacing[2], left: spacing[3]};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.spacing[property]\t\t= spacing;\n\t\t}\n\t}, this.shape);\n\n\t// Prepare shape transforms\n\tif (('transform' in this.shape) && _.isArray(this.shape.transform)) {\n\t\ttransforms\t\t\t\t\t\t= this.shape.transform;\n\t}\n\n\t// Alternatively use deprecated top-level transforms\n\t// TODO: Remove in future version\n\tif ('transform' in config) {\n\t\tthis.log.warn('The top-level `transform` option is deprecated and will be removed in a future version. Please use `shape.transform` instead.');\n\n\t\tif ((transforms === null) && _.isArray(config.transform)) {\n\t\t\ttransforms\t\t\t\t\t= config.transform;\n\t\t}\n\t}\n\n\t// Fallback: Use default transformations\n\tif (transforms === null) {\n\t\ttransforms\t\t\t\t\t\t= defaultShapeTransform;\n\t}\n\n\tthis.shape.transform\t\t\t\t= [];\n\tif (_.isArray(transforms)) {\n\t\ttransformers: for (t = 0; t < transforms.length; ++t) {\n\t\t\tif (_.isString(transforms[t])) {\n\t\t\t\ttransforms[t]\t\t\t= JSON.parse('{\"' + transforms[t] + '\":true}');\n\t\t\t} else if (_.isFunction(transforms[t])) {\n\t\t\t\tvar custom\t\t\t\t= {};\n\t\t\t\tcustom.custom\t\t\t= transforms[t];\n\t\t\t\ttransforms[t]\t\t\t= custom;\n\t\t\t}\n\t\t\tif (_.isObject(transforms[t])) {\n\t\t\t\tfor (var transformer in transforms[t]) {\n\t\t\t\t\tvar tconfig\t\t\t= transforms[t][transformer];\n\t\t\t\t\tif ((tconfig === true) || _.isObject(tconfig) || _.isFunction(tconfig)) {\n\t\t\t\t\t\tthis.shape.transform.push([transformer, (tconfig === true) ? {} : tconfig]);\n\t\t\t\t\t\tcontinue transformers;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.log.debug('Prepared `shape` options');\n\n\tthis.svg\t\t\t\t\t\t\t= _.clone(defaultSVGConfig);\n\tthis.svg\t\t\t\t\t\t\t= ('svg' in config) ? _.assign(this.svg, config.svg || {}) : this.svg;\n\tthis.svg.xmlDeclaration\t\t\t\t= this.svg.xmlDeclaration || false;\n\tthis.svg.doctypeDeclaration\t\t\t= this.svg.doctypeDeclaration || false;\n\tthis.svg.dimensionAttributes\t\t= this.svg.dimensionAttributes || false;\n\tthis.svg.rootAttributes\t\t        = this.svg.rootAttributes || {};\n\tthis.svg.precision                  = Math.max(-1, parseInt(this.svg.precision || -1));\n\n\t// Prepare post-processing transforms\n\ttransforms\t\t\t\t\t\t\t= [];\n\tif ('transform' in this.svg) {\n\t\tif (_.isFunction(this.svg.transform)) {\n\t\t\ttransforms.push(this.svg.transform);\n\t\t} else if (_.isArray(this.svg.transform)) {\n\t\t\tfor (t = 0; t < this.svg.transform.length; ++t) {\n\t\t\t\tif (_.isFunction(this.svg.transform[t])) {\n\t\t\t\t\ttransforms.push(this.svg.transform[t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tthis.svg.transform\t\t\t\t\t= transforms;\n\n\tthis.log.debug('Prepared `svg` options');\n\n\tthis.mode\t\t\t\t\t\t\t= this.filter(config.mode);\n\n\tthis.log.debug('Prepared `mode` options');\n\n\tthis.variables\t\t\t\t\t\t= _.extend({}, config.variables);\n\n\tthis.log.debug('Prepared `variables` options');\n\n\tthis.log.verbose('Initialized spriter configuration');\n}\n\n/**\n * Pick out the relevant mode options out of a configuration object\n *\n * @param {Object} config\t\t\t\tConfiguration object\n * @return {Object}\t\t\t\t\t\tMode relevant options\n */\nSVGSpriterConfig.prototype.filter = function(config) {\n\tvar filtered\t\t\t\t\t\t= {};\n\tconfig\t\t\t\t\t\t\t\t= config || {};\n\tfor (var m in config) {\n\t\tvar modeConfig\t\t\t\t\t= _.isPlainObject(config[m]) ? config[m] : ((config[m] === true) ? {} : null);\n\t\tif ((modeConfig !== null) && (spriteTypes.indexOf(modeConfig.mode || m) >= 0)) {\n\t\t\tfiltered[m]\t\t\t\t\t= modeConfig;\n\t\t\tfiltered[m].mode\t\t\t= modeConfig.mode || m;\n\t\t}\n\t}\n\treturn filtered;\n};\n\n/**\n * Module export (constructor wrapper)\n *\n * @param {Object} config\t\t\t\tConfiguration\n * @return {SVGSpriterConfig}\t\t\tSVGSpriter configuration\n */\nmodule.exports = function(config) {\n\treturn new SVGSpriterConfig(config || {});\n};\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/queue.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar path\t\t\t\t= require('path'),\nasync\t\t\t\t\t= require('async'),\nos\t\t\t\t\t\t= require('os'),\nevents\t\t\t\t\t= require('events'),\nSHAPE\t\t\t\t\t= require('./shape');\n\n/**\n * SVGSpriter queue\n *\n * @param {SVGSpriter} spriter\t\t\tSVGSpriter instance\n */\nfunction SVGSpriterQueue(spriter) {\n\tthis._spriter\t\t= spriter;\n\tthis._files\t\t\t= [];\n\tthis._limit\t\t\t= os.cpus().length * 2;\n\tthis.active\t\t\t= 0;\n\n\tevents.EventEmitter.call(this);\n\tthis.on('add', this.process.bind(this));\n\tthis.on('remove', this.process.bind(this));\n\n\tthis._spriter.debug('Created processing queue instance');\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriterQueue.prototype = Object.create(events.EventEmitter.prototype);\n\n/**\n * Add a shape to the processing queue\n *\n * @param {File} file\t\t\t\t\tShape file\n */\nSVGSpriterQueue.prototype.add = function(file) {\n\tthis._spriter.debug('Added \"%s\" to processing queue', file.path.substr(file.base.length + path.sep.length));\n\tthis._files.push(file);\n\tthis.emit('add');\n};\n\n/**\n * Try to process an item in the queue\n */\nSVGSpriterQueue.prototype.process = function() {\n\tif (this._files.length && (this.active < this._limit)) {\n\t\t++this.active;\n\t\tvar file\t\t= this._files.shift();\n\n\t\t// Instanciate the shape\n\t\ttry {\n\t\t\tvar shape\t= new SHAPE(file, this._spriter),\n\t\t\tspriter\t\t= this._spriter;\n\n\t\t// In case of errors: Skip the file\n\t\t} catch(e) {\n\t\t\tthis._spriter.error('Skipping \"%s\" (%s)', file.path.substr(file.base.length + path.sep.length), e.message);\n\t\t\tthis.emit(--this.active ? 'remove' : 'empty');\n\t\t\treturn;\n\t\t}\n\n\t\t// Subsequently run through all optimization and compilation tasks\n\t\tasync.waterfall([\n\n\t\t\t// Transform the shape\n\t\t\tfunction(_cb){\n\t\t\t\tspriter._transformShape(shape, _cb);\n\t\t\t},\n\n\t\t\t// Complement the shape\n\t\t\tfunction(_cb){\n\t\t\t\tshape.complement(_cb);\n\t\t\t}\n\n\t\t], this.remove.bind(this));\n\t}\n};\n\n/**\n * Remove a shape from the queue\n *\n * @param {Error} error\t\t\t\t\tError\n * @param {SVGShape} shape\t\t\t\tProcessed shape\n */\nSVGSpriterQueue.prototype.remove = function(error, shape) {\n\tArray.prototype.push.apply(this._spriter._shapes, shape.distribute());\n\tthis.emit(--this.active ? 'remove' : 'empty');\n};\n\n/**\n * Module export (constructor wrapper)\n *\n * @param {SVGSpriter} spriter\t\t\tSVGSpriter instance\n * @return {SVGSpriterQueue}\t\t\tSVGSpriterQueue instance\n */\nmodule.exports = SVGSpriterQueue;\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/shape.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _\t\t\t\t\t\t= require('lodash'),\npath\t\t\t\t\t\t= require('path'),\nutil\t\t\t\t\t\t= require('util'),\nxmldom\t\t\t\t\t\t= require('xmldom'),\nDOMParser\t\t\t\t\t= xmldom.DOMParser,\nXMLSerializer\t\t\t\t= xmldom.XMLSerializer,\nxpath\t\t\t\t\t\t= require('xpath'),\ncssom\t\t\t\t\t\t= require('cssom'),\nCssSelectorParser\t\t\t= require('css-selector-parser').CssSelectorParser,\ncsssel\t\t\t\t\t\t= new CssSelectorParser(),\nexecFile\t\t\t\t\t= require('child_process').execFile,\nphantomjs\t\t\t\t\t= require('phantomjs-prebuilt').path,\ndimensionsPhantomScript\t\t= path.resolve(__dirname, 'shape/dimensions.phantom.js'),\nasync\t\t\t\t\t\t= require('async'),\n/**\n * Default callback for shape ID generation\n *\n * @param {String} template\t\t\tTemplate string\n * @return {String}\t\t\t\t\tShape ID\n */\ncreateIdGenerator\t\t\t= function(template) {\n\t/**\n\t * ID generator\n\t *\n\t * @param {String} name\t\t\tRelative file path\n\t * @param {File} file\t\t\tOriginal vinyl file\n\t * @returns {String}\t\t\tShape ID\n     */\n\tvar generator = function(name, file) {\n\t\treturn util.format(template || '%s', path.basename(name.split(path.sep).join(this.separator).replace(/\\s+/g, this.whitespace), '.svg'));\n\t};\n\treturn generator;\n},\n/**\n * Default shape configuration\n *\n * @type {Object}\n */\ndefaultConfig\t\t\t\t= {\n\t/**\n\t * Shape ID related options\n\t *\n\t * @type {Object}\n\t */\n\tid\t\t\t\t\t\t: {\n\t\t/**\n\t\t * ID part separator (used for directory-to-ID traversal)\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tseparator\t\t\t: '--',\n\t\t/**\n\t\t * Pseudo selector separator\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tpseudo\t\t\t\t: '~',\n\t\t/**\n\t\t * Whitespace replacement string\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\twhitespace\t\t\t: '_',\n\t\t/**\n\t\t * ID traversal callback\n\t\t *\n\t\t * @param {Function}\n\t\t */\n\t\tgenerator\t\t\t: createIdGenerator('%s')\n\t},\n\t/**\n\t * Dimension related options\n\t *\n\t * @type {Object}\n\t */\n\tdimension\t\t\t\t: {\n\t\t/**\n\t\t * Max. shape width\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tmaxWidth\t\t\t: 2000,\n\t\t/**\n\t\t * Max. shape height\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tmaxHeight\t\t\t: 2000,\n\t\t/**\n\t\t * Coordinate decimal places\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tprecision\t\t\t: 2,\n\t\t/**\n\t\t * Add dimension attributes\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tattributes\t\t\t: false\n\t},\n\t/**\n\t * Spacing related options\n\t *\n\t * @type {Number}\n\t */\n\tspacing\t\t\t\t\t: {\n\t\t/**\n\t\t * Padding around the shape\n\t\t *\n\t\t * @type {Number|Array}\n\t\t */\n\t\tpadding\t\t\t\t: {top: 0, right: 0, bottom: 0, left: 0},\n\t\t/**\n\t\t * Box sizing strategy\n\t\t *\n\t\t * Might be 'content' (padding is added outside of the shape), 'padding' (shape plus padding will make for the given maximum size)\n\t\t * or 'contain' (like 'padding', but size will be fixed instead of maximum)\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tbox\t\t\t\t\t: 'content'\n\t}\n},\nsvgReferenceProperties\t\t= ['style', 'fill', 'stroke', 'filter', 'clip-path', 'mask',  'marker-start', 'marker-end', 'marker-mid'];\n\n/**\n * SVGShape\n *\n * @param {File} file\t\t\t\t\tVinyl file\n * @param {SVGSpriter} spriter\t\t\tSpriter instance\n */\nfunction SVGShape(file, spriter) {\n\tthis.source\t\t\t\t= file;\n\tthis.spriter\t\t\t= spriter;\n\tthis.svg\t\t\t\t= {current: this.source.contents.toString(), ready: null};\n\tthis.name\t\t\t\t= this.source.path.substr(this.source.base.length + path.sep.length);\n\tthis.config\t\t\t\t= _.merge(_.clone(defaultConfig, true), this.spriter.config.shape || {});\n\n\tif (!_.isFunction(this.config.id.generator)) {\n\t\tthis.config.id.generator\t\t= createIdGenerator(_.isString(this.config.id.generator) ? (this.config.id.generator + ((this.config.id.generator.indexOf('%s') >= 0) ? '' : '%s')) : '%s');\n\t}\n\n\tthis.id\t\t\t\t\t= this.config.id.generator(this.name, this.source);\n\tthis.state\t\t\t\t= this.id.split(this.config.id.pseudo);\n\tthis.base\t\t\t\t= this.state.shift();\n\tthis.state\t\t\t\t= this.state.shift() || null;\n\tthis.master\t\t\t\t= null;\n\tthis.copies\t\t\t\t= 0;\n\tthis._precision\t\t\t= Math.pow(10, +this.config.dimension.precision);\n\tthis._scale\t\t\t\t= 1;\n\tthis._namespaced\t\t= false;\n\n\t// Determine meta & alignment data\n\tvar relative\t\t\t= path.basename(this.source.relative, '.svg');\n\tthis.meta\t\t\t\t= (this.id in this.config.meta) ? this.config.meta[this.id] : ((relative in this.config.meta) ? this.config.meta[relative] : {});\n\tthis.align\t\t\t\t= _.toPairs(_.extend({}, this.config.align['*'], (this.id in this.config.align) ? this.config.align[this.id] : ((relative in this.config.align) ? this.config.align[relative] : {})));\n\n\t// Initially set the SVG of this shape\n\tthis._initSVG();\n\n\t// XML declaration and doctype\n\tvar xmldecl\t\t\t\t= this.svg.current.match(/<\\?xml.*?>/gi),\n\tdoctype\t\t\t\t\t= this.svg.current.match(/<!DOCTYPE.*?>/gi);\n\tthis.xmlDeclaration\t\t= xmldecl ? xmldecl[0] : '<?xml version=\"1.0\" encoding=\"utf-8\"?>';\n\tthis.doctypeDeclaration\t= doctype ? doctype[0] : '';\n\n\tthis.spriter.verbose('Added shape \"%s:%s\"', this.base, this.state || 'regular');\n}\n\n/**\n * Prototype properties\n *\n * @type {Object}\n */\nSVGShape.prototype = {};\n\n/**\n * SVG stages\n *\n * @type {Object}\n */\nSVGShape.prototype.svg\t\t= null;\n\n/**\n * Default SVG namespace\n *\n * @type {String}\n */\nSVGShape.prototype.DEFAULT_SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\n/**\n * Xlink namespace\n *\n * @type {String}\n */\nSVGShape.prototype.XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';\n\n/**\n * Return a string representation of the shape\n *\n * @return {String}\t\t\tString representation\n */\nSVGShape.prototype.toString = function() {\n\treturn '[object SVGShape]';\n};\n\n/**\n * Recursively strip unneeded namespace declarations\n *\n * @param {Element} element \tElement\n * @param {Object} nsMap\t\tNamespace map\n * @return {Element}\t\t\tElement\n */\nSVGShape.prototype._stripInlineNamespaceDeclarations = function(element, nsMap) {\n\tvar parentNsMap\t\t\t\t= _.clone(element._nsMap);\n\tnsMap\t\t\t\t\t\t= nsMap || {'': this.DEFAULT_SVG_NAMESPACE};\n\n\t// Strip the default SVG namespace\n\tif (nsMap[''] === this.DEFAULT_SVG_NAMESPACE) {\n\t\tvar defaultNamespace\t= element.attributes.getNamedItem('xmlns');\n\t\tif (!_.isUndefined(defaultNamespace) && (defaultNamespace.value === this.DEFAULT_SVG_NAMESPACE)) {\n\t\t\telement.attributes.removeNamedItem('xmlns');\n\t\t}\n\t}\n\n\tif (!('xlink' in nsMap) || (nsMap.xlink === this.XLINK_NAMESPACE)) {\n\t\tvar xlinkNamespace\t\t= element.attributes.getNamedItem('xmlns:xlink');\n\t\tif (!_.isUndefined(xlinkNamespace) && (xlinkNamespace.value === this.XLINK_NAMESPACE)) {\n\t\t\telement.attributes.removeNamedItem('xmlns:xlink');\n\t\t}\n\t}\n\n\tfor (var c = 0; c < element.childNodes.length; ++c) {\n\t\tif (element.childNodes.item(c).nodeType === 1) {\n\t\t\tthis._stripInlineNamespaceDeclarations(element.childNodes.item(c), parentNsMap);\n\t\t}\n\t}\n\n\treturn element;\n};\n\n/**\n * Return the SVG of this shape\n *\n * @param {Boolean}\tinline\t\t\tPrepare for inline usage (strip redundant XML namespaces)\n * @param {Function} transform\t\tFinal transformer before serialization (operating on a clone)\n * @return {String}\t\t\t\t\tSVG\n */\nSVGShape.prototype.getSVG = function(inline, transform) {\n\tvar svg;\n\n\t// If this is a distributed copy\n\tif (this.master) {\n\t\tsvg\t\t\t\t\t= this.dom.createElementNS(this.DEFAULT_SVG_NAMESPACE, 'use');\n\t\tsvg.setAttribute('xlink:href', '#' + this.master.id);\n\n\t// Else\n\t} else {\n\t\tsvg\t\t\t\t\t= this.dom.documentElement.cloneNode(true);\n\t}\n\n\t// Call the final transformer (if available)\n\tif (_.isFunction(transform)) {\n\t\ttransform(svg);\n\t}\n\n\t// If the SVG is to be used inline or as part of a sprite or is a distributed copy: Strip redundand namespace declarations\n\tif (inline || this.master) {\n\t\treturn new XMLSerializer().serializeToString(this._stripInlineNamespaceDeclarations(svg));\n\n\t// Else: Add XML and DOCTYPE declarations if required\n\t} else {\n\t\tsvg\t\t\t\t\t= new XMLSerializer().serializeToString(svg);\n\n\t\t// Add DOCTYPE declaration\n\t\tif (this.spriter.config.svg.doctypeDeclaration) {\n\t\t\tsvg\t\t\t\t= this.doctypeDeclaration + svg;\n\t\t}\n\n\t\t// Add XML declaration\n\t\tif (this.spriter.config.svg.xmlDeclaration) {\n\t\t\tsvg\t\t\t\t= this.xmlDeclaration + svg;\n\t\t}\n\t}\n\n\treturn svg;\n};\n\n/**\n * Set the SVG of this shape\n *\n * @param {String} svg\t\tSVG\n * @return {SVGShape}\t\tSelf reference\n */\nSVGShape.prototype.setSVG = function(svg) {\n\tthis.svg.current\t\t= svg;\n\tthis.svg.ready\t\t\t= null;\n\treturn this._initSVG();\n};\n\n/**\n * Initialize the SVG of this shape\n *\n * @return {SVGShape}\t\tSelf reference\n */\nSVGShape.prototype._initSVG = function() {\n\n\t// Basic check for basic SVG file structure\n\tvar svgStart\t\t\t= this.svg.current.match(/<svg(?:\\s+[a-z0-9-\\:]+=(\"|').*?\\1)*\\s*(?:(\\/)|(>[^]*<\\/svg))>/i);\n\tif (!svgStart) {\n\t\tvar e\t\t\t\t= new Error('Invalid SVG file');\n\t\te.name\t\t\t\t= 'ArgumentError';\n\t\te.errno\t\t\t\t= 1429395394;\n\t\tthrow e;\n\t}\n\n\t// Resolve XML entities\n\tvar entityRegExp\t\t= /<!ENTITY\\s+([^\\s]+)\\s+(\"|')(.+)(?:\\2)>/i;\n\tvar entityStart\t\t\t= 0;\n\tvar entities\t\t\t= 0;\n\tvar entityMap\t\t\t= {};\n\tvar entity;\n\tdo {\n\t\tentity\t\t\t\t= entityRegExp.exec(this.svg.current.substr(entityStart));\n\t\tif (entity) {\n\t\t\t++entities;\n\t\t\tentityStart\t\t+= entity.index + entity[0].length;\n\t\t\tentityMap[entity[1]] = entity[3];\n\t\t}\n\t} while(entity);\n\tif (entities) {\n\t\tvar svg\t\t\t\t= this.svg.current.substr(svgStart.index);\n\t\tfor (entity in entityMap) {\n\t\t\tsvg\t\t\t\t= svg.replace('&' + entity + ';', entityMap[entity]);\n\t\t}\n\t\tthis.svg.current\t= this.svg.current.substr(0, svgStart.index) + svg;\n\t}\n\n\t// Parse the XML\n\tthis.dom\t\t\t\t= new DOMParser({\n\t\tlocator\t\t\t\t: {},\n\t\terrorHandler\t\t: function(level, message) {\n\t\t\tvar e\t\t\t= new Error(util.format('Invalid SVG file (%s)', message.split('\\n').join(' ')));\n\t\t\te.name\t\t\t= 'ArgumentError';\n\t\t\te.errno\t\t\t= 1429394706;\n\t\t\tthrow e;\n\t\t}\n\t}).parseFromString(this.svg.current);\n\n\t// Determine the shape width\n\tvar width\t\t\t\t= this.dom.documentElement.getAttribute('width');\n\tthis.width\t\t\t\t= width.length ? parseFloat(width, 10) : false;\n\n\t// Determine the shape height\n\tvar height\t\t\t\t= this.dom.documentElement.getAttribute('height');\n\tthis.height\t\t\t\t= height.length ? parseFloat(height, 10) : false;\n\n\t// Determine the viewbox\n\tvar viewBox\t\t\t\t= this.dom.documentElement.getAttribute('viewBox');\n\tif (viewBox.length) {\n\t\tviewBox\t\t\t\t= viewBox.split(/[^-\\d\\.]+/);\n\t\twhile (viewBox.length < 4) {\n\t\t\tviewBox.push(0);\n\t\t}\n\t\tviewBox.forEach(function(value, index) {\n\t\t\tviewBox[index]\t= parseFloat(value, 10);\n\t\t});\n\t\tthis.viewBox\t\t= viewBox;\n\t} else {\n\t\tthis.viewBox\t\t= false;\n\t}\n\n\tthis.title\t\t\t\t=\n\tthis.description\t\t= null;\n\tfor (var c = 0, children = this.dom.documentElement.childNodes, cl = children.length, meta = {title: 'title', description: 'desc'}; c < cl; ++c) {\n\t\tfor (var m in meta) {\n\t\t\tif (meta[m] === children.item(c).localName) {\n\t\t\t\tthis[m]\t\t= children.item(c);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this;\n};\n\n/**\n * Return the dimensions of this shape\n *\n * @return {Object}\t\t\t\tDimensions\n */\nSVGShape.prototype.getDimensions = function() {\n\treturn {width: this.width, height: this.height};\n};\n\n/**\n * Set the dimensions of this shape\n *\n * @param {Number} width\t\tWidth\n * @param {Number} height\t\tHeight\n * @return {SVGShape}\t\t\tSelf reference\n */\nSVGShape.prototype.setDimensions = function(width, height) {\n\tthis.width\t\t\t\t= this._round(Math.max(0, parseFloat(width, 10)));\n\tthis.dom.documentElement.setAttribute('width', this.width);\n\tthis.height\t\t\t\t= this._round(Math.max(0, parseFloat(height, 10)));\n\tthis.dom.documentElement.setAttribute('height', this.height);\n\treturn this;\n};\n\n/**\n * Return the shape's viewBox (and set it if it doesn't exist yet)\n *\n * @param {Number} width\t\tWidth\n * @param {Height} height\t\tHeight\n * @return {Array}\t\t\t\tViewbox\n */\nSVGShape.prototype.getViewbox = function(width, height) {\n\tif (!this.viewBox) {\n\t\tthis.setViewbox(0, 0, width || this.width, height || this.height);\n\t}\n\treturn this.viewBox;\n};\n\n/**\n * Set the shape's viewBox\n *\n * @param {Number} x\t\t\tX coordinate\n * @param {Number} y\t\t\tY coordinate\n * @param {Number} width\t\tWidth\n * @param {Number} height\t\tHeight\n * @return {Array}\t\t\t\tViewbox\n */\nSVGShape.prototype.setViewbox = function(x, y, width, height) {\n\tif (_.isArray(x)) {\n\t\tthis.viewBox\t\t= x.map(function(n) { return parseFloat(n, 10); });\n\t\twhile (this.viewBox.length < 4) {\n\t\t\tthis.viewBox.push(0);\n\t\t}\n\t} else {\n\t\tthis.viewBox\t\t= [parseFloat(x, 10), parseFloat(y, 10), parseFloat(width, 10), parseFloat(height, 10)];\n\t}\n\tthis.dom.documentElement.setAttribute('viewBox', this.viewBox.join(' '));\n\treturn this.viewBox;\n};\n\n/**\n * Complement the SVG shape by adding dimensions, padding and meta data\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype.complement = function(cb) {\n\tvar that\t\t\t\t= this;\n\tasync.waterfall([\n\n\t\t// Prepare dimensions\n\t\tthis._complementDimensions.bind(this),\n\n\t\t// Set padding\n\t\tthis._addPadding.bind(this),\n\n\t\t// Set meta data\n\t\tthis._addMetadata.bind(this)\n\n\t], function(error) {\n\n\t\t// Save the transformed state\n\t\tthat.svg.ready\t\t= new XMLSerializer().serializeToString(that.dom.documentElement);\n\t\tcb(error, that);\n\t});\n};\n\n/**\n * Complement the shape's dimensions\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype._complementDimensions = function(cb) {\n\tif (this.width && this.height) {\n\t\tthis._setDimensions(cb);\n\t} else {\n\t\tthis._determineDimensions(this._setDimensions.bind(this, cb));\n\t}\n};\n\n/**\n * Determine the shape's dimension by rendering it\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype._determineDimensions = function(cb) {\n\n\t// Try to use a viewBox attribute for image determination\n\tif (this.viewBox !== false) {\n\t\tthis.width\t\t\t\t= this.viewBox[2];\n\t\tthis.height\t\t\t\t= this.viewBox[3];\n\t}\n\n\t// If the viewBox attribute didn't suffice: Render the SVG image\n\tif (!this.width || !this.height) {\n\t\tvar that\t\t\t\t= this;\n\t    execFile(phantomjs, [dimensionsPhantomScript, this.getSVG(false), 'file://' + this.source.path], function (err, stdout, stderr) {\n\t        if (err) {\n\t            cb(err);\n\t        } else if (stdout.length > 0) { // PhantomJS always outputs to stdout.\n\t        \tvar dimensions\t= JSON.parse(stdout.toString().trim());\n\t        \tthat.width\t\t= dimensions.width;\n\t        \tthat.height\t\t= dimensions.height;\n\t        \tcb(null);\n\t        } else if (stderr.length > 0) {\n\t            cb(new Error(stderr.toString().trim()));\n\t        } else {\n\t            cb(new Error('PhantomJS didn\\'t return dimensions for \"' + that.name + '\"'));\n\t        }\n\t    });\n\t} else {\n\t\tcb(null);\n\t}\n};\n\n/**\n * Round a number considering the given decimal place precision\n *\n * @param {Number} n\t\t\tNumber\n * @return {Number}\t\t\t\tRounded number\n */\nSVGShape.prototype._round = function(n) {\n\treturn Math.round(n * this._precision) / this._precision;\n};\n\n/**\n * Scale the shape if necessary\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype._setDimensions = function(cb) {\n\n\t// Ensure the original viewBox is set\n\tthis.getViewbox(this.width, this.height);\n\n\tvar includePadding\t\t= (['padding', 'icon'].indexOf(this.config.spacing.box) >= 0),\n\tforceScale\t\t\t\t= (this.config.spacing.box === 'icon'),\n\thorizontalPadding\t\t= includePadding * Math.max(0, this.config.spacing.padding.right + this.config.spacing.padding.left),\n\twidth\t\t\t\t\t= this.width + horizontalPadding,\n\tverticalPadding\t\t\t= includePadding * Math.max(0, this.config.spacing.padding.top + this.config.spacing.padding.bottom),\n\theight\t\t\t\t\t= this.height + verticalPadding;\n\n\t// Does the shape need to be scaled?\n\tif ((width > this.config.dimension.maxWidth) || (height > this.config.dimension.maxHeight) || (forceScale && (width < this.config.dimension.maxWidth) && (height < this.config.dimension.maxHeight))) {\n\t\tvar maxWidth\t\t= this.config.dimension.maxWidth - horizontalPadding,\n\t\tmaxHeight\t\t\t= this.config.dimension.maxHeight - verticalPadding;\n\t\tthis._scale\t\t\t= Math.min(maxWidth / this.width, maxHeight / this.height);\n\t\tthis.width\t\t\t= Math.min(maxWidth, this._round(this.width * this._scale));\n\t\tthis.height\t\t\t= Math.min(maxHeight, this._round(this.height * this._scale));\n\t}\n\n\t// In \"icon\" box sizing mode: Resize bounding box and center shape by adding padding\n\tif (forceScale) {\n\t\tvar diffWidth\t\t= this.config.dimension.maxWidth - this.width - horizontalPadding,\n\t\tdiffHeight\t\t\t= this.config.dimension.maxHeight - this.height - verticalPadding;\n\t\tthis.config.spacing.padding.left\t\t+= diffWidth / 2;\n\t\tthis.config.spacing.padding.right\t\t+= diffWidth / 2;\n\t\tthis.config.spacing.padding.top\t\t\t+= diffHeight / 2;\n\t\tthis.config.spacing.padding.bottom\t\t+= diffHeight / 2;\n\t}\n\n\tvar dimensions\t\t\t= this.getDimensions();\n\tfor (var attr in dimensions) {\n\t\tthis.dom.documentElement.setAttribute(attr, dimensions[attr]);\n\t}\n\tcb(null);\n};\n\n/**\n * Add padding to this shape\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype._addPadding = function(cb) {\n\tvar padding\t\t\t\t= this.config.spacing.padding;\n\tif (padding.top || padding.right || padding.bottom || padding.left) {\n\n\t\t// Update viewBox\n\t\tvar viewBox\t\t\t= this.getViewbox();\n\t\tviewBox[0]\t\t\t-= this.config.spacing.padding.left / this._scale;\n\t\tviewBox[1]\t\t\t-= this.config.spacing.padding.top / this._scale;\n\t\tviewBox[2]\t\t\t+= (this.config.spacing.padding.right + this.config.spacing.padding.left) / this._scale;\n\t\tviewBox[3]\t\t\t+= (this.config.spacing.padding.top + this.config.spacing.padding.bottom) / this._scale;\n\t\tthis.setViewbox(viewBox.map(this._round.bind(this)));\n\n\t\t// Update dimensions\n\t\tthis.setDimensions(this.width + this.config.spacing.padding.right + this.config.spacing.padding.left, this.height + this.config.spacing.padding.top + this.config.spacing.padding.bottom);\n\t}\n\tcb(null);\n};\n\n/**\n * Add metadata to this shape\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype._addMetadata = function(cb) {\n\tvar ariaLabelledBy\t\t\t\t\t= [];\n\n\t// Check if description meta data is available\n\tif (('description' in this.meta) && _.isString(this.meta.description) && this.meta.description.length) {\n\t\tif (!this.description) {\n\t\t\tthis.description\t\t\t= this.dom.documentElement.insertBefore(this.dom.createElementNS(this.DEFAULT_SVG_NAMESPACE, 'desc'), this.dom.documentElement.firstChild);\n\t\t}\n\t\tthis.description.textContent\t= this.meta.description;\n\t\tthis.description.setAttribute('id', this.id + '-desc');\n\t\tariaLabelledBy.push(this.id + '-desc');\n\t}\n\n\t// Check if title meta data is available\n\tif (('title' in this.meta) && _.isString(this.meta.title) && this.meta.title.length) {\n\t\tif (!this.title) {\n\t\t\tthis.title\t\t\t\t\t= this.dom.documentElement.insertBefore(this.dom.createElementNS(this.DEFAULT_SVG_NAMESPACE, 'title'), this.dom.documentElement.firstChild);\n\t\t}\n\t\tthis.title.textContent\t\t\t= this.meta.title;\n\t\tthis.title.setAttribute('id', this.id + '-title');\n\t\tariaLabelledBy.push(this.id + '-title');\n\t}\n\n\tif (ariaLabelledBy.length) {\n\t\tthis.dom.documentElement.setAttribute('aria-labelledby', ariaLabelledBy.join(' '));\n\t} else if (this.dom.documentElement.hasAttribute('aria-labelledby')) {\n\t\tthis.dom.documentElement.removeAttribute('aria-labelledby');\n\t}\n\n\tcb(null);\n};\n\n/**\n * Apply a namespace prefix to all IDs within the SVG document\n *\n * @param {String} ns\t\t\t\tID namespace\n */\nSVGShape.prototype.setNamespace = function(ns) {\n\tvar namespaceIds                   = !!this.spriter.config.svg.namespaceIDs;\n\tvar namespaceClassnames            = !!this.spriter.config.svg.namespaceClassnames;\n\tif (!this._namespaced && (namespaceIds || namespaceClassnames)) {\n\n\t\t// Ensure the shape has been complemented before\n\t\tif (!this.svg.ready) {\n\t\t\tvar error\t\t\t\t   = new Error('Shape namespace cannot be set before complementing');\n\t\t\terror.name\t\t\t\t   = 'NotPermittedError';\n\t\t\terror.errno\t\t\t\t   = 1419162245;\n\t\t\tthrow error;\n\t\t}\n\n\t\tvar select\t\t\t\t\t   = xpath.useNamespaces({'svg': this.DEFAULT_SVG_NAMESPACE, 'xlink': this.XLINK_NAMESPACE});\n\t\tvar substIds                   = null;\n\t\tvar substClassnames            = null;\n\n\t\t// If IDs should be namespaced\n\t\tif (namespaceIds) {\n\n    \t\t// Build an ID substitution table (and alter the elements' IDs accordingly)\n    \t\tsubstIds\t\t\t\t    = {};\n    \t\tselect('//*[@id]', this.dom).forEach(function(elem) {\n    \t\t\tvar id\t\t\t\t\t= elem.getAttribute('id'),\n    \t\t\tsubstId\t\t\t\t\t= ns + id;\n    \t\t\tsubstIds['#' + id]\t\t= substId;\n    \t\t\telem.setAttribute('id', substId);\n    \t\t});\n\n    \t\t// Substitute ID references in xlink:href attributes\n    \t\tselect('//@xlink:href', this.dom).forEach(function(xlink){\n    \t\t\tvar xlinkValue\t\t\t= xlink.nodeValue;\n    \t\t\tif ((xlinkValue.indexOf('data:') !== 0) && (xlinkValue in substIds)) {\n    \t\t\t\txlink.ownerElement.setAttribute('xlink:href', '#' + substIds[xlinkValue]);\n    \t\t\t}\n    \t\t});\n\n    \t\t// Substitute ID references in referencing attributes\n    \t\tsvgReferenceProperties.forEach(function(refProperty){\n    \t\t\tselect('//@' + refProperty, this.dom).forEach(function(ref) {\n    \t\t\t\tref.ownerElement.setAttribute(ref.localName, this._replaceIdAndClassnameReferences(ref.nodeValue, substIds, substClassnames, false));\n    \t\t\t}, this);\n    \t\t}, this);\n\n    \t\t// Substitute ID references in aria-labelledby attribute\n    \t\tif (this.dom.documentElement.hasAttribute('aria-labelledby')) {\n    \t\t\tthis.dom.documentElement.setAttribute('aria-labelledby', this.dom.documentElement.getAttribute('aria-labelledby').split(' ').map(function(label){\n    \t\t\t\treturn (('#' + label) in substIds) ? substIds['#' + label] : label;\n    \t\t\t}).join(' '));\n    \t\t}\n\t\t}\n\n\t\t// If CSS class names should be namespaced\n\t\tif (namespaceClassnames) {\n\n\t\t\t// Build a class name substitution table (and alter the elements' class names accordingly)\n\t\t\tsubstClassnames             = {};\n            select('//*[@class]', this.dom).forEach(function(elem) {\n            \tvar elemClassnames      = [];\n                elem.getAttribute('class').split(' ').filter(function(classname){\n                    return classname.trim();\n                }).forEach(function(classname){\n                    var substClassname  = ns + classname;\n                    substClassnames['.' + classname]      = substClassname;\n                    elemClassnames.push(substClassname);\n                });\n                elem.setAttribute('class', elemClassnames.join(' '));\n            });\n\t\t}\n\n        // Substitute ID references in <style> elements\n        var style                       = select('//svg:style', this.dom);\n        if (style.length) {\n            var cssmin                  = require('cssmin');\n            select('//svg:style', this.dom).forEach(function(style) {\n                style.textContent       = cssmin(this._replaceIdAndClassnameReferences(style.textContent, substIds, substClassnames, true));\n            }, this);\n        }\n\n\t\tthis._namespaced\t\t\t    = true;\n\t}\n};\n\n/**\n * Reset the shapes namespace\n */\nSVGShape.prototype.resetNamespace = function() {\n\tif (this._namespaced && !!this.spriter.config.svg.namespaceIDs) {\n\t\tthis._namespaced\t\t= false;\n\t\tthis.dom\t\t\t\t= new DOMParser().parseFromString(this.svg.ready);\n\t}\n};\n\n/**\n * Replace ID references\n *\n * @param {String} str\t\t\t        String\n * @param {Object} substIds\t\t        ID substitutions\n * @param {Object} substClassnames\t\tClass name substitutions\n * @param {Boolean} selectors\t        Substitute CSS selectors\n * @return {String}\t\t\t\t        String with replaced ID and class name references\n */\nSVGShape.prototype._replaceIdAndClassnameReferences = function(str, substIds, substClassnames, selectors) {\n\n\t// If ID replacement is to be applied: Replace url()-style ID references\n\tif (substIds !== null) {\n    \tstr = str.replace(/url\\s*\\(\\s*[\"']?([^\\)]+)[\"']?\\s*\\)/g, function(match, id){\n    \t\treturn 'url(' + ((id in substIds) ? ('#' + substIds[id]) : id) + ')';\n    \t});\n\t}\n\n\treturn selectors ? this._replaceIdAndClassnameReferencesInCssSelectors(str, cssom.parse(str).cssRules, substIds, substClassnames) : str;\n};\n\n/**\n * Recursively replace ID references in CSS selectors\n *\n * @param {String} str\t\t\t        Original CSS text\n * @param {Array} rules\t\t\t        CSS rules\n * @param {Object} substIds             ID substitutions\n * @param {Object} substClassnames      Class name substitutions\n * @return {String}\t\t\t\t        Substituted CSS text\n */\nSVGShape.prototype._replaceIdAndClassnameReferencesInCssSelectors = function(str, rules, substIds, substClassnames) {\n\tvar css\t\t\t\t\t\t= '';\n\n\trules.forEach(function(rule) {\n\t\tvar selText\t\t\t    = rule.selectorText;\n\n\t\t// @-rule\n\t\tif (_.isUndefined(selText)) {\n\n\t\t\t// If there's a key text: Copy the CSS rule\n\t\t\tif (rule.keyText) {\n\t\t\t\tcss\t\t\t\t+= str.substr(rule.__starts, rule.__ends);\n\n\t\t\t// Else: Recursively process rule content\n\t\t\t} else if (_.isArray(rule.cssRules)) {\n\t\t\t\tcss\t\t\t\t+= str.substring(rule.__starts, rule.cssRules[0].__starts) + this._replaceIdAndClassnameReferencesInCssSelectors(str, rule.cssRules, substIds, substClassnames) + str.substring(rule.cssRules[rule.cssRules.length - 1].__ends, rule.__ends);\n\t\t\t}\n\n\t\t// Regular selector\n\t\t} else {\n\t\t\tvar origSelText\t\t= selText;\n\t\t\tvar sel\t\t\t\t= csssel.parse(selText);\n\t\t\tvar ids\t\t\t\t= [];\n\t\t\tvar classnames      = [];\n\t\t\tvar classnameFilter = function(classname){\n                if (('.' + classname) in substClassnames) {\n                    classnames.push(classname);\n                }\n            };\n\t\t\tvar idOrClassSubstitution = function(sel){\n\t\t\t\t// If ID substitution should be applied: Search for an ID\n\t\t\t\tif (('id' in sel.rule) && (substIds !== null) && (('#' + sel.rule.id) in substIds)) {\n\t\t\t\t\tids.push(sel.rule.id);\n\t\t\t\t}\n\n\t\t\t\t// If class name substitution should be applied: Search for class names\n\t\t\t\tif (('classNames' in sel.rule) && (substClassnames !== null) && _.isArray(sel.rule.classNames)) {\n\t\t\t\t\tsel.rule.classNames.forEach(classnameFilter);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// If there are multiple subselectors, substitute all of them\n\t\t\tif ('selectors' in sel) {\n\t\t\t\tsel.selectors.forEach(idOrClassSubstitution);\n\t\t\t}\n\n\t\t\t// While there are nested rules: Substitute and recurse\n\t\t\twhile ((typeof(sel) === 'object') && ('rule' in sel)) {\n\t\t\t\tidOrClassSubstitution(sel);\n\t\t\t\tsel\t\t\t\t= sel.rule;\n\t\t\t}\n\n\t\t\t// Substitute IDs within the selector\n\t\t\tif (ids.length) {\n\t\t\t\tids.sort(function(a, b){\n\t\t\t\t\treturn b.length - a.length;\n\t\t\t\t});\n\t\t\t\tids.forEach(function(id) {\n\t\t\t\t\tselText\t\t= selText.split('#' + id).join('#' + substIds['#' + id]);\n\t\t\t\t}, this);\n\t\t\t}\n\n\t\t\t// Substitute class names within the selector\n\t\t\tif (classnames.length) {\n\t\t\t\tclassnames      = _.uniq(classnames);\n\t\t\t\tclassnames.sort(function(a, b){\n                    return b.length - a.length;\n                });\n                classnames.forEach(function(classname) {\n                    selText     = selText.split('.' + classname).join('.' + substClassnames['.' + classname]);\n                }, this);\n\t\t\t}\n\n\t\t\t// Rebuild the selector\n\t\t\tcss\t\t\t\t\t+= selText + str.substring(rule.__starts + origSelText.length, rule.__ends);\n\t\t}\n\t}, this);\n\n\treturn css;\n};\n\n/**\n * Create distribute to several copies (if configured)\n *\n * @return {Array}\t\t\t\tDisplaced copies\n */\nSVGShape.prototype.distribute = function() {\n\tvar copies\t\t\t\t\t= [],\n\talignments\t\t\t\t\t= this.align.slice(0),\n\talign\t\t\t\t\t\t= alignments.shift(),\n\tbase\t\t\t\t\t\t= this.base;\n\tthis.base\t\t\t\t\t= util.format(align[0], this.base);\n\tthis.id\t\t\t\t\t\t= this.base + (this.state ? (this.config.id.pseudo + this.state) : '');\n\tthis.align\t\t\t\t\t= align[1];\n\tcopies.push(this);\n\n\t// Run through all remaining alignments\n\talignments.forEach(function(alignment){\n\t\tvar copy\t\t\t\t= _.merge(new SVGShape(this.source, this.spriter), this);\n\t\tcopy.base\t\t\t\t= util.format(alignment[0], base);\n\t\tcopy.id\t\t\t\t\t= copy.base + (this.state ? (this.config.id.pseudo + this.state) : '');\n\t\tcopy.align\t\t\t\t= alignment[1];\n\t\tcopy.master\t\t\t\t= this;\n\t\tcopies.push(copy);\n\t}, this);\n\n\tthis.copies\t\t\t\t\t= alignments.length;\n\treturn copies;\n};\n\n/**\n * Module export (constructor wrapper)\n *\n * @param {String} svg\t\t\tSVG content\n * @param {String} name\t\t\tName part or the file path\n * @param {String} file\t\t\tAbsolute file path\n * @param {Object} config\t\tSVG shape configuration\n * @return {SVGShape}\t\t\tSVGShape instance\n */\nmodule.exports = function(svg, name, file, config) {\n\treturn new SVGShape(svg, name, file, config || {});\n};\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/transform/svgo.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2015 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar SVGO\t\t\t\t\t\t\t= require('svgo'),\n_\t\t\t\t\t\t\t\t\t= require('lodash'),\npretty\t\t\t\t\t\t\t\t= require('prettysize'),\ndefaultPluginConfig\t\t\t\t\t= [\n//\t{cleanupAttrs\t\t\t\t\t: true}, // cleanup attributes from newlines, trailing and repeating spaces\n//\t{removeDoctype\t\t\t\t\t: true}, // remove doctype declaration\n//\t{removeXMLProcInst\t\t\t\t: true}, // remove XML processing instructions\n//\t{removeComments\t\t\t\t\t: true}, // remove comments\n//\t{removeMetadata\t\t\t\t\t: true}, // remove `<metadata>`\n//\t{removeTitle\t\t\t\t\t: true}, // remove `<title>`\n//\t{removeEditorsNSData\t\t\t: true}, // remove editors namespaces, elements and attributes\n//\t{removeEmptyAttrs\t\t\t\t: true}, // remove empty attributes\n//\t{removeHiddenElems\t\t\t\t: true}, // remove hidden elements\n//\t{removeEmptyText\t\t\t\t: true}, // remove empty Text elements\n//\t{removeEmptyContainers\t\t\t: true}, // remove empty Container elements\n\t{removeViewBox\t\t\t\t\t: false}, // remove `viewBox` attribute when possible\n//\t{cleanupEnableBackground\t\t: true}, // remove or cleanup `enable-background` attribute when possible\n//\t{convertStyleToAttrs\t\t\t: true}, // convert styles into attributes\n//\t{convertColors\t\t\t\t\t: true}, // convert colors (from `rgb()` to `#rrggbb`, from `#rrggbb` to `#rgb`)\n//\t{convertPathData\t\t\t\t: true}, // convert Path data to relative, convert one segment to another, trim useless delimiters and much more\n//\t{convertTransform\t\t\t\t: true}, // collapse multiple transforms into one, convert matrices to the short aliases and much more\n//\t{removeUnknownsAndDefaults\t\t: true}, // remove unknown elements content and attributes, remove attrs with default values\n//\t{removeNonInheritableGroupAttrs\t: true}, // remove non-inheritable group's \"presentation\" attributes\n//\t{removeUnusedNS\t\t\t\t\t: true}, // remove unused namespaces declaration\n//\t{cleanupIDs\t\t\t\t\t\t: true}, // remove unused and minify used IDs\n//\t{cleanupNumericValues\t\t\t: true}, // round numeric values to the fixed precision, remove default 'px' units\n//\t{moveElemsAttrsToGroup\t\t\t: true}, // move elements attributes to the existing group wrapper\n\t{moveGroupAttrsToElems\t\t\t: false} // move some group attributes to the content elements\n//\t{collapseGroups\t\t\t\t\t: true}, // collapse useless groups\n//\t{removeRasterImages\t\t\t\t: false}, // remove raster images (disabled by default)\n//\t{mergePaths\t\t\t\t\t\t: true}, // merge multiple Paths into one\n//\t{convertShapeToPath\t\t\t\t: true}, // convert some basic shapes to path\n//\t{transformsWithOnePath\t\t\t: true}, // apply transforms, crop by real width, center vertical alignment and resize SVG with one Path inside\n];\n\n/**\n * SVGO transformation\n *\n * @param {SVGShape} shape\t\t\t\tSVG shape\n * @param {Object} config\t\t\t\tTransform configuration\n * @param {SVGSpriter} spriter\t\t\tSpriter instance\n * @param {Function} cb\t\t\t\t\tCallback\n */\nmodule.exports = function(shape, config, spriter, cb) {\n\tconfig\t\t\t\t\t\t\t= _.cloneDeep(config);\n\tconfig.plugins\t\t\t\t\t= ('plugins' in config) ? defaultPluginConfig.concat(config.plugins) : defaultPluginConfig;\n\tconfig.plugins.push({removeXMLProcInst: !!spriter.config.svg.xmlDeclaration});\n\tconfig.plugins.push({removeDoctype: !!spriter.config.svg.doctypeDeclaration});\n\n\tvar svg\t\t\t\t\t\t\t= shape.getSVG(false),\n\tsvgLength\t\t\t\t\t\t= svg.length,\n\tsvgoInstance\t\t\t\t\t= new SVGO(config);\n\n\ttry {\n\t\tsvgoInstance.optimize(svg, function(result) {\n\t\t\tshape.setSVG(result.data);\n\n\t\t\tif (spriter.config.log.transports.console.level === 'debug') {\n\t\t\t\tvar optSVGLength\t= shape.getSVG(false).length;\n\t\t\t\tspriter.debug('Optimized \"%s\" with SVGO (saved %s / %s%%)', shape.name, pretty(svgLength - optSVGLength), Math.round(100 * (svgLength - optSVGLength) / svgLength));\n\t\t\t}\n\n\t\t\tcb(null);\n\t\t});\n\t} catch (error) {\n\t\tspriter.error('Optimizing \"%s\" with SVGO failed with error \"%s\"', shape.name, error);\n\t\tcb(error);\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/layouter.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _                               = require('lodash'),\ndefaultConfig                       = {\n    css                             : {\n        dest                        : 'css',\n        layout                      : 'packed',\n        common                      : null,\n        mixin\t\t\t\t\t\t: null,\n        prefix                      : '.svg-%s',\n        dimensions                  : '-dims',\n        sprite                      : 'svg/sprite.css.svg',\n        bust\t\t\t\t\t\t: true\n    },\n    view                            : {\n        dest                        : 'view',\n        layout                      : 'packed',\n        common                      : null,\n        mixin\t\t\t\t\t\t: null,\n        prefix                      : '.svg-%s',\n        dimensions                  : '-dims',\n        sprite                      : 'svg/sprite.view.svg',\n        bust\t\t\t\t\t\t: true\n    },\n    defs                            : {\n        dest                        : 'defs',\n        prefix                      : '.svg-%s',\n        dimensions                  : '-dims',\n        sprite                      : 'svg/sprite.defs.svg',\n        inline\t\t\t\t\t\t: false,\n        example\t\t\t\t\t\t: false,\n        bust\t\t\t\t\t\t: false\n    },\n    symbol                          : {\n        dest                        : 'symbol',\n        prefix                      : '.svg-%s',\n        dimensions                  : '-dims',\n        sprite                      : 'svg/sprite.symbol.svg',\n        inline\t\t\t\t\t\t: false,\n        example\t\t\t\t\t\t: false,\n        bust\t\t\t\t\t\t: false\n    },\n    stack\t\t\t\t\t\t\t: {\n        dest                        : 'stack',\n        prefix                      : '.svg-%s',\n        dimensions                  : '-dims',\n        sprite                      : 'svg/sprite.stack.svg',\n        example\t\t\t\t\t\t: false,\n        bust\t\t\t\t\t\t: false\n    }\n},\ndefaultVariables                    = {\n    date                            : (new Date()).toGMTString(),\n    invert                          : function() {\n        return function(num, render) {\n            return -parseFloat(render(num), 10);\n        };\n    },\n    classname                       : function() {\n        return function(str, render) {\n        \tvar classname\t\t\t= render(str).replace(/\\s+/g, ' ').split(' ').pop();\n        \treturn (classname.indexOf('.') === 0) ? classname.substr(1) : classname;\n        };\n    },\n    escape                          : function() {\n        return function(str, render) {\n            return render(str).split('\\\\').join('\\\\\\\\');\n        };\n    }\n};\n\n/**\n * SVGSprite layouter\n *\n * @param {SVGSpriter} spriter\t\tSVG spriter\n * @param {Object} config\t\t\tLayout configuration\n */\nfunction SVGSpriteLayouter(spriter, config) {\n    this._spriter                   = spriter;\n    this.config                     = config;\n    this.mode                       = null;\n    this.files                      = {};\n    this.data                       = {};\n    this._commonData                = _.extend({shapes: []}, defaultVariables, this._spriter.config.variables);\n\n    // Register the common shapes data\n    this._spriter._shapes.forEach(function(shape, index) {\n        var dimensions              = shape.getDimensions(),\n        padding                     = shape.config.spacing.padding;\n\n        this._commonData.shapes.push({\n            name                    : shape.id,\n            base                    : shape.base,\n            master                  : shape.master ? shape.master.id : null,\n            width                   : {\n                inner               : dimensions.width - padding.right - padding.left,\n                outer               : dimensions.width\n            },\n            height                  : {\n                inner               : dimensions.height - padding.top - padding.bottom,\n                outer               : dimensions.height\n            },\n            first                   : !index,\n            last                    : (index === (this._spriter._shapes.length - 1))\n        });\n    }, this);\n\n    this._spriter.debug('Created layouter instance');\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriteLayouter.prototype = {};\n\n/**\n * Layout as a sprite\n *\n * @param {Object} files            Files\n * @param {String} key\t\t\t\tResult key\n * @param {String} mode\t\t\t\tMode\n * @param {Function} cb             Callback\n */\nSVGSpriteLayouter.prototype.layout = function(files, key, mode, cb) {\n\tthis._spriter.info('Laying out «%s» sprite («%s» mode)', key, mode);\n\tvar SVGSpriteLayout\t\t\t\t= require('./mode/' + mode),\n    config                          = _.merge(_.merge(_.clone(defaultConfig[mode], true), {svg: this._spriter.config.svg}), this.config[key] || {}),\n    data                            = _.merge(_.merge(_.merge({}, this._commonData), this._spriter.config.variables), config.variables),\n    sprite                          = new SVGSpriteLayout(this._spriter, config, data, key);\n    files[key]\t\t\t\t\t\t= {};\n    sprite.layout(files[key], cb);\n};\n\n/**\n * Module export (constructor wrapper)\n *\n * @param {SVGSpriter} spriter\t\tSVG spriter\n * @param {Object} config\t\t\tLayout configuration\n * @return {SVGSpriteLayouter}\t\tSVGSpriter Layouter\n */\nmodule.exports = SVGSpriteLayouter;\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/bin/svg-sprite.js":"#!/usr/bin/env node\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n */\nvar _ = require('lodash'),\n\tpath = require('path'),\n\tfs = require('fs'),\n\tmkdirp = require('mkdirp'),\n\tFile = require('vinyl'),\n\tyaml = require('js-yaml'),\n\tglob = require('glob'),\n\tSVGSpriter = require('../lib/svg-sprite'),\n\tconfig = {},\n\tJSONConfig = {mode: {}},\n\tmap = {},\n\tyargs = require('yargs')\n\t\t.usage('Create one or multiple sprites of the given SVG files, optionally along with some stylesheet resources.\\nUsage: $0 [options] files')\n\t\t.version('version', 'Show version number', JSON.parse(fs.readFileSync(path.resolve(__dirname, '..', 'package.json'), {encoding: 'utf8'})).version)\n\t\t.help('help', 'Display this help information')\n\t\t.wrap(null)\n\t\t.example('$0 --css --css-render-css --css-example --dest=out assets/*.svg', 'Create a CSS sprite of the given SVG files including example document to the subdirectory \"out\"')\n\t\t.example('$0 -cD out --ccss --cx assets/*.svg', 'Same as above')\n\t\t.example('$0 -cD out --cscss -p 10 assets/*.svg', 'Render Sass instead of CSS and add 10px padding around all shapes (no example document this time)')\n\t\t.showHelpOnFail(true)\n\t\t.demand(1);\n\n/**\n * Add a command line option\n *\n * @param {String} name Option name\n * @param {Object} option Option configuration\n * @return {void}\n */\nfunction addOption(name, option) {\n\tvar alias = name;\n\n\t// If the this is an option itself\n\tif ('description' in option) {\n\t\tif ('alias' in option) {\n\t\t\talias = option.alias;\n\t\t\tyargs = yargs.alias(alias, name);\n\t\t}\n\n\t\tyargs = yargs.describe(alias, option.description);\n\n\t\tif ('default' in option) {\n\t\t\tvar template = (name.substr(-9) === '-template'),\n\t\t\t\tdef = template ? path.resolve(path.dirname(__dirname), option.default) : option.default;\n\t\t\tyargs = yargs.default(alias, def);\n\n\t\t\tif ((option.default === true) || (option.default === false)) {\n\t\t\t\tyargs = yargs.boolean(name);\n\t\t\t}\n\n\t\t} else if (option.required) {\n\t\t\tyargs = yargs.require(alias);\n\t\t}\n\n\t\tif ('map' in option) {\n\t\t\tmap[option.map] = name;\n\t\t}\n\t}\n\n\tvar children = _.omit(option, ['description', 'alias', 'default', 'map']);\n\tfor (var sub in children) {\n\t\taddOption(name + '-' + sub, children[sub]);\n\t}\n}\n\n/**\n * Add a value to the global configuration\n *\n * @param {Object} store Configuration\n * @param {Array} path Path\n * @param {Mixed} value Value\n */\nfunction addConfigMap(store, path, value) {\n\tvar key = path.shift();\n\tif (path.length) {\n\t\tif (!(key in store) || !_.isObject(store[key])) {\n\t\t\tstore[key] = {};\n\t\t}\n\t\taddConfigMap(store[key], path, value);\n\t} else {\n\t\tstore[key] = value;\n\t}\n}\n\n/**\n * Recursively merge two config objects\n *\n * @param {Object} from Source configuration\n * @param {Object} to Target configuration\n */\nfunction mergeConfig(from, to) {\n\tfor (var f in from) {\n\t\tif (_.isObject(from[f])) {\n\t\t\tif (!_.isObject(to[f])) {\n\t\t\t\tto[f] = from[f];\n\t\t\t} else {\n\t\t\t\tmergeConfig(from[f], to[f]);\n\t\t\t}\n\t\t} else {\n\t\t\tto[f] = from[f];\n\t\t}\n\t}\n}\n\n/**\n * Recursively write files to disc\n *\n * @param {Object} files Files\n * @return {Number} Number of written files\n */\nfunction writeFiles(files) {\n\tvar written = 0;\n\tfor (var key in files) {\n\t\tif (_.isObject(files[key])) {\n\t\t\tif (files[key].constructor === File) {\n\t\t\t\tmkdirp.sync(path.dirname(files[key].path));\n\t\t\t\tfs.writeFileSync(files[key].path, files[key].contents);\n\t\t\t\t++written;\n\t\t\t} else {\n\t\t\t\twritten += writeFiles(files[key]);\n\t\t\t}\n\t\t}\n\t}\n\treturn written;\n}\n\n// Get document, or throw exception on error\ntry {\n\tvar options = yaml.safeLoad(fs.readFileSync(path.resolve(__dirname, 'config.yaml'), 'utf8'));\n\tfor (var name in options) {\n\t\taddOption(name, options[name]);\n\t}\n\n} catch (e) {\n\tconsole.log(e);\n}\n\nvar argv = yargs.argv;\n\n// Map all arguments to a global configuration object\nfor (var m in map) {\n\tif (!(map[m] in argv)) {\n\t\tcontinue;\n\t}\n\taddConfigMap(config, m.split('.'), argv[map[m]]);\n}\n\n// Load external JSON config file\nif (argv['config']) {\n\ttry {\n\t\tvar file = argv['config'];\n\t\tdelete argv['config'];\n\t\tdelete argv['C'];\n\t\tvar JSONConfigContent = fs.readFileSync(path.resolve(file));\n\t\tvar externalConfig = JSON.parse(JSONConfigContent);\n\n\t\t// Make a clone of initial config for options removal checks\n\t\tJSONConfig = JSON.parse(JSONConfigContent);\n\t\tif (!('mode' in JSONConfig)) {\n\t\t\tJSONConfig['mode'] = {};\n\t\t}\n\n\t\t// Expand shorthand mode definitions\n\t\tif (('mode' in externalConfig) && _.isObject(externalConfig.mode)) {\n\t\t\tfor (var emode in externalConfig.mode) {\n\t\t\t\tif (externalConfig.mode[emode] === true) {\n\t\t\t\t\texternalConfig.mode[emode] = JSONConfig.mode[emode] = {\n\t\t\t\t\t\trender: {\n\t\t\t\t\t\t\tcss: true\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmergeConfig(externalConfig, config);\n\t} catch (e) {\n\t\tconsole.error('[ERROR] Skipping --config file due to errors (\"%s\")', e.message.trim());\n\t}\n}\n\n// Refine particular config options\nconfig.shape.spacing.padding = ('' + config.shape.spacing.padding).trim();\nconfig.shape.spacing.padding = config.shape.spacing.padding.length ? config.shape.spacing.padding.split(',').map(function (dim) {\n\treturn parseFloat(dim || 0, 10);\n}) : [];\n\nif (config.svg.rootAttributes) {\n\ttry {\n\t\tvar JSONAttributesContent = fs.readFileSync(path.resolve(config.svg.rootAttributes));\n\t\tconfig.svg.rootAttributes = JSON.parse(JSONAttributesContent);\n\t} catch (e) {\n\t\tconsole.error('[ERROR] Skipping --svg-rootattrs file due to errors (\"%s\")', e.message.trim());\n\t\tconfig.svg.rootAttributes = {};\n\t}\n}\n\n// Expand transformation options\nvar transform = ('' + config.shape.transform).trim();\nconfig.shape.transform = [];\n(transform.length ? transform.split(',').map(function (trans) {\n\treturn ('' + trans).trim();\n}) : []).forEach(function (transform) {\n\tif (transform.length) {\n\t\tif (('shape-transform-' + transform) in argv) {\n\t\t\ttry {\n\t\t\t\tvar transformConfigFile = argv['shape-transform-' + transform],\n\t\t\t\t\ttransformConfigJSON = fs.readFileSync(path.resolve(transformConfigFile), {encoding: 'utf8'}),\n\t\t\t\t\ttransformConfig = transformConfigJSON.trim() ? JSON.parse(transformConfigJSON) : {};\n\t\t\t\tthis.push(_.zipObject([transform], [transformConfig]));\n\t\t\t} catch (e) {\n\t\t\t}\n\t\t} else {\n\t\t\tthis.push(transform);\n\t\t}\n\t}\n}, config.shape.transform);\n\n// Run through all sprite modes\n['css', 'view', 'defs', 'symbol', 'stack'].forEach(function (mode) {\n\tif (!argv[mode] && !(mode in JSONConfig.mode)) {\n\t\tdelete this[mode];\n\t\treturn;\n\t}\n\n\t// Remove excessive render types\n\t['css', 'scss', 'less', 'styl'].forEach(function (render) {\n\t\tvar arg = mode + '-render-' + render;\n\t\tif ((render in this) && !argv[arg]\n\t\t\t&& (!(mode in JSONConfig.mode)\n\t\t\t|| !('render' in JSONConfig.mode[mode])\n\t\t\t|| !(render in JSONConfig.mode[mode].render))\n\t\t) {\n\t\t\tdelete this[render];\n\t\t}\n\t}, this[mode].render);\n\n\tif (!this[mode].dimensions.length) {\n\t\tthis[mode].dimensions = true;\n\t}\n}, config.mode);\n\n// Remove excessive example options\nfor (var mode in config.mode) {\n\tvar example = mode + '-example';\n\tif (!argv[example]\n\t\t&& (!(mode in JSONConfig.mode) || !('example' in JSONConfig.mode[mode]))\n\t\t&& ('example' in config.mode[mode])\n\t) {\n\t\tdelete config.mode[mode].example;\n\t}\n}\n\n// Read & parse Mustache variable JSON file\nif ('variables' in config) {\n\tvar variables = ('' + config.variables).trim();\n\tdelete config.variables;\n\tvariables = variables.length ? path.resolve(variables) : null;\n\tif (variables && fs.existsSync(variables)) {\n\t\ttry {\n\t\t\tconfig.variables = JSON.parse(fs.readFileSync(variables));\n\t\t} catch (e) {\n\t\t\tconsole.error('[ERROR] Skipping --variables file due to errors (\"%s\")', e.message.trim());\n\t\t}\n\t}\n}\n\nvar spriter = new SVGSpriter(config);\n_.reduce(argv._, function (f, g) {\n\treturn f.concat(glob.sync(g));\n}, []).forEach(function (file) {\n\tfile = path.resolve(file);\n\tvar stat = fs.lstatSync(file);\n\tif (stat.isSymbolicLink()) {\n\t\tfile = fs.readlinkSync(file);\n\t}\n\tspriter.add(file, path.basename(file), fs.readFileSync(file));\n});\n\nspriter.compile(function (error, result /*, data*/) {\n\tif (error) {\n\t\tconsole.error(error);\n\t} else {\n\t\twriteFiles(result);\n\t}\n});\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/sprite.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _\t\t\t\t\t\t\t\t= require('lodash'),\nFile\t\t\t\t\t\t\t\t= require('vinyl');\n\n/**\n * SVGSprite\n *\n * @param {String} xmlDeclaration\t\tXML declaration\n * @param {String} doctypeDeclaration\tDoctype declaration\n * @param {Object} rootAttributes\t\tRoot attributes\n * @param {Boolean} addSVGNamespaces\tAdd default SVG namespaces\n * @param {Array} transform\t\t\t\tList of post-processing transform callbacks\n */\nfunction SVGSprite(xmlDeclaration, doctypeDeclaration, rootAttributes, addSVGNamespaces, transform) {\n\tthis.xmlDeclaration\t\t\t\t= xmlDeclaration || '';\n\tthis.doctypeDeclaration\t\t\t= doctypeDeclaration || '';\n\tthis.rootAttributes\t\t\t\t= _.extend({}, rootAttributes);\n\tthis.transform\t\t\t\t\t= transform;\n\tthis.content\t\t\t\t\t= [];\n\tthis._serialized\t\t\t\t= null;\n\n\tif (!!addSVGNamespaces) {\n\t\tthis.rootAttributes['xmlns']\t\t= this.DEFAULT_SVG_NAMESPACE;\n\t\tthis.rootAttributes['xmlns:xlink']\t= this.XLINK_NAMESPACE;\n\t}\n}\n\n/**\n * Prototype properties\n *\n * @type {Object}\n */\nSVGSprite.prototype = {};\n\n/**\n * Default SVG namespace\n *\n * @type {String}\n */\nSVGSprite.prototype.DEFAULT_SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\n/**\n * Xlink namespace\n *\n * @type {String}\n */\nSVGSprite.prototype.XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';\n\n/**\n * Add a content string\n *\n * @param {String} content\t\t\tContent string\n * @return {SVGSprite}\t\t\t\tSelf reference\n */\nSVGSprite.prototype.add = function(content) {\n\tif (_.isArray(content)) {\n\t\tthis.content.push.apply(this.content, content);\n\t} else {\n\t\tthis.content.push(content);\n\t}\n\n\tthis._serialized\t\t\t\t= null;\n};\n\n/**\n * Serialize the SVG sprite\n *\n * @return {String}\t\t\t\t\tSVG sprite\n */\nSVGSprite.prototype.toString = function() {\n\tif (this._serialized === null) {\n\t\tvar svg\t\t\t\t\t\t= this.xmlDeclaration + this.doctypeDeclaration;\n\t\tsvg\t\t\t\t\t\t\t+= '<svg';\n\t\tfor (var attr in this.rootAttributes) {\n\t\t\tsvg\t\t\t\t\t\t+= ' ' + attr + '=\"' + _.escape(this.rootAttributes[attr]) + '\"';\n\t\t}\n\t\tsvg\t\t\t\t\t\t\t+= '>';\n\t\tsvg\t\t\t\t\t\t\t+= this.content.join('');\n\t\tsvg\t\t\t\t\t\t\t+= '</svg>';\n\n\t\t// Apply post-processing transformations\n\t\tfor (var t = 0; t < this.transform.length; ++t) {\n\t\t\tif (_.isFunction(this.transform[t])) {\n\t\t\t\tsvg\t\t\t\t\t= this.transform[t](svg) || '';\n\t\t\t}\n\t\t}\n\n\t\tthis._serialized\t\t\t= svg;\n\t}\n\n\treturn this._serialized;\n};\n\n/**\n * Return as vinyl file\n *\n * @param {String} base\t\t\t\tBase path\n * @param {String} path\t\t\t\tPath\n * @return {File}\t\t\t\t\tVinyl file\n */\nSVGSprite.prototype.toFile = function(base, path) {\n\treturn new File({\n\t\tbase\t\t\t\t\t\t: base,\n\t\tpath\t\t\t\t\t\t: path,\n\t\tcontents\t\t\t\t\t: new Buffer(this.toString())\n\t});\n};\n\n/**\n * Module export\n */\nmodule.exports = SVGSprite;\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/mode/base.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar path\t\t\t\t\t\t\t= require('path'),\n_\t\t\t\t\t\t\t\t\t= require('lodash'),\nfs\t\t\t\t\t\t\t\t\t= require('fs'),\nasync\t\t\t\t\t\t\t\t= require('async'),\nmustache\t\t\t\t\t\t\t= require('mustache'),\nos \t\t\t\t\t\t\t\t\t= require('os'),\nFile\t\t\t\t\t\t\t\t= require('vinyl'),\ncrypto\t\t\t\t\t\t\t\t= require('crypto');\n\n/**\n * Sprite base class\n *\n * @param {SVGSpriter} spriter\t\tSVG spriter\n * @param {Object} config\t\t\tConfiguration\n * @param {Object} data\t\t\t\tBase data\n * @param {String} key\t\t\t\tMode key\n */\nfunction SVGSpriteBase(spriter, config, data, key) {\n\tthis._spriter\t\t\t\t\t= spriter;\n\tthis.config\t\t\t\t\t\t= config;\n\tthis.key\t\t\t\t\t\t= key || this.mode;\n\tthis.data\t\t\t\t\t\t= data;\n\tthis.data.mode\t\t\t\t\t= this.mode;\n\tthis.data.key\t\t\t\t\t= this.key;\n\n\t// Resolve file paths\n\tthis.config.dest\t\t\t\t= path.resolve(this._spriter.config.dest, this.config.dest);\n\tif ('sprite' in this.config) {\n\t\tvar spriteName\t\t\t\t= path.basename(this.config.sprite) || 'sprite',\n\t\tspritePath\t\t\t\t\t= path.dirname(this.config.sprite);\n\t\tif (spriteName.indexOf('.') < 0) {\n\t\t\tspriteName\t\t\t\t+= '.svg';\n\t\t}\n\t\tthis.config.sprite\t\t\t= path.resolve(this.config.dest, path.join(spritePath, spriteName));\n\t}\n\n\t// Prepare the rendering configurations\n\tif (('render' in this.config) && _.isObject(this.config.render)) {\n\t\tfor (var extension in this.config.render) {\n\t\t\tvar renderConfig\t\t= {\n\t\t\t\ttemplate\t\t\t: path.resolve(path.dirname(path.dirname(path.dirname(__dirname))), path.join('tmpl', this.tmpl, 'sprite.' + extension)),\n\t\t\t\tdest\t\t\t\t: path.join(this.config.dest, 'sprite.' + extension)\n\t\t\t};\n\t\t\tif (_.isObject(this.config.render[extension])) {\n\t\t\t\tif ('template' in this.config.render[extension]) {\n\t\t\t\t\trenderConfig.template\t\t= path.resolve(process.cwd(), this.config.render[extension].template);\n\t\t\t\t}\n\t\t\t\tif ('dest' in this.config.render[extension]) {\n\t\t\t\t\trenderConfig.dest\t\t\t= path.resolve(this.config.dest, this.config.render[extension].dest);\n\t\t\t\t\tif (!renderConfig.dest.match(new RegExp('\\\\.' + extension + '$', 'i'))) {\n\t\t\t\t\t\trenderConfig.dest\t\t+= '.' + extension;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (this.config.render[extension] !== true) {\n\t\t\t\tdelete this.config.render[extension];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.config.render[extension]\t\t= renderConfig;\n\t\t}\n\t\tthis._cssDest\t\t\t\t= ('css' in this.config.render) ? path.dirname(this.config.render.css.dest) : this.config.dest;\n\t} else {\n\t\tthis._cssDest\t\t\t\t= this.config.dest;\n\t}\n\n\t// Cache busting\n\tthis.config.bust\t\t\t\t= !!this.config.bust;\n\n\t// Prepare the CSS prefix\n\tthis.config.prefix\t\t\t\t= this.config.prefix.trim();\n\tif (!/%s/g.test(this.config.prefix.split('%%').join(''))) {\n\t\tthis.config.prefix\t\t\t+= '%s';\n\t}\n\n\t// Refine the base data\n\tthis.data\t\t\t\t\t\t= _.merge(this.data, this._initData({\n\t\tpadding\t\t\t\t\t\t: this._spriter.config.shape.spacing.padding,\n\t\tsprite\t\t\t\t\t\t: path.relative(this._cssDest, this.config.sprite).split(path.sep).join('/')\n\t}));\n\n\tthis._init();\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriteBase.prototype = {\n\tMODE_CSS\t\t\t\t\t\t: 'css',\n\tMODE_DEFS\t\t\t\t\t\t: 'defs',\n\tMODE_SYMBOL\t\t\t\t\t\t: 'symbol',\n\tMODE_STACK\t\t\t\t\t\t: 'stack',\n\tMODE_VIEW\t\t\t\t\t\t: 'view',\n\n\ttmpl\t\t\t\t\t\t\t: 'common'\n};\n\n/**\n * Extended data initialization\n *\n * @param {Object} data\t\t\t\tData\n * @return {Object}\t\t\t\t\tExtended data\n */\nSVGSpriteBase.prototype._initData = function(data) {\n\n\t// If the HTML example should be rendered\n\tif (this.config.example) {\n\t\tvar renderConfig\t\t\t= {\n\t\t\ttemplate\t\t\t\t: path.resolve(path.dirname(path.dirname(path.dirname(__dirname))), path.join('tmpl', this.mode, 'sprite.html')),\n\t\t\tdest\t\t\t\t\t: path.join(this.config.dest, 'sprite.' + this.key + '.html')\n\t\t};\n\t\tif (_.isObject(this.config.example)) {\n\t\t\tif ('template' in this.config.example) {\n\t\t\t\trenderConfig.template\t\t= path.resolve(process.cwd(), this.config.example.template);\n\t\t\t}\n\t\t\tif ('dest' in this.config.example) {\n\t\t\t\trenderConfig.dest\t\t\t= path.resolve(this.config.dest, this.config.example.dest);\n\t\t\t}\n\t\t} else if (this.config.example !== true) {\n\t\t\trenderConfig\t\t\t= false;\n\t\t}\n\t\tthis.config.example\t\t\t= renderConfig;\n\t\tdata.example\t\t\t\t= path.relative(path.dirname(renderConfig.dest), this.config.sprite).split(path.sep).join('/');\n\t}\n\n\tthis._spriter.debug('Created «%s» sprite instance («%s» mode)', this.key, this.mode);\n\n\treturn data;\n};\n\n/**\n * Layout the sprite\n *\n * @param {Array} files\t\t\t\tFiles\n * @param {Function} cb\t\t\t\tCallback\n * @return {void}\n */\nSVGSpriteBase.prototype.layout = function(files, cb) {\n\tcb(null);\n};\n\n/**\n * Build the configured CSS resources\n *\n * @param {Array} files\t\t\t\tFiles\n * @param {Function} cb\t\t\t\tCallback\n * @return {void}\n */\nSVGSpriteBase.prototype._buildCSSResources = function(files, cb) {\n\tvar tasks\t\t\t\t\t\t= [],\n\tcreateResourceTask\t\t\t\t= function(renderConfig, data, spriter, ext){\n\t\treturn function(_cb) {\n\t\t\tvar out\t\t\t\t\t= mustache.render(fs.readFileSync(renderConfig.template, 'utf-8'), data);\n\t\t\tif (out.length) {\n\t\t\t\tfiles[ext]\t\t\t= new File({\n\t\t\t\t\tbase\t\t\t: spriter.config.dest,\n\t\t\t\t\tpath\t\t\t: renderConfig.dest,\n\t\t\t\t\tcontents\t\t: new Buffer(out)\n\t\t\t\t});\n\t\t\t\tspriter.verbose('Created «%s» stylesheet resource', ext);\n\t\t\t}\n\t\t\t_cb(null);\n\t\t};\n\t};\n\n\tfor (var extension in this.config.render) {\n\t\ttasks.push(createResourceTask(this.config.render[extension], this.data, this._spriter, extension));\n\t}\n\n\tasync.parallelLimit(tasks, os.cpus().length * 2, cb);\n};\n\n/**\n * Build the HTML example (non-CSS modes)\n *\n * @param {Array} files\t\t\t\tFiles\n * @param {Function} cb\t\t\t\tCallback\n * @return {void}\n */\nSVGSpriteBase.prototype._buildHTMLExample = function(files, cb) {\n\tif (this.config.example) {\n\t\tvar out\t\t\t\t\t\t= mustache.render(fs.readFileSync(this.config.example.template, 'utf-8'), this.data);\n\t\tif (out.length) {\n\t\t\tfiles.example\t\t\t= new File({\n\t\t\t\tbase\t\t\t\t: this._spriter.config.dest,\n\t\t\t\tpath\t\t\t\t: this.config.example.dest,\n\t\t\t\tcontents\t\t\t: new Buffer(out)\n\t\t\t});\n\t\t\tthis._spriter.verbose('Created «%s» HTML example file', this.key);\n\t\t}\n\t}\n\n\tcb(null, this.data);\n};\n\n/**\n * Return a coordinate (number) with 'px' appended if non-zero\n *\n * @param {Number} number \t\t\tCoordinate (number)\n * @param {String} unit\t\t\t\tUnit\n * @return {String} \t\t\t\tCoordinate (number) with unit appended\n */\nSVGSpriteBase.prototype._addUnit = function(number, unit) {\n\treturn number + ((number !== 0) ? (unit || 'px') : '');\n};\n\n/**\n * Evaluate and return a declaration value\n *\n * @param {Mixed} global\t\t\tGlobal declaration setting\n * @param {String} local\t\t\tLocal declaration value\n * @return {String}\t\t\t\t\tEvaluated declaration value\n */\nSVGSpriteBase.prototype.declaration = function(global, local) {\n\tif (global === true) {\n\t\treturn local || '';\n\t}\n\treturn String(global || '').trim();\n};\n\n/**\n * Add cache busting\n *\n * @param {SVGSprite} svg\t\t\tSVG sprite\n * @return {String}\t\t\t\t\tSprite path\n */\nSVGSpriteBase.prototype._addCacheBusting = function(svg) {\n\tvar sprite\t\t\t\t\t\t= this.config.sprite;\n\tif (this.config.bust) {\n\t\tvar hash\t\t\t\t\t= '-' + crypto.createHash('md5')\n\t\t\t\t\t\t\t\t\t.update(svg.toString(), 'utf8')\n\t\t\t\t\t\t\t\t\t.digest('hex')\n\t\t\t\t\t\t\t\t\t.substr(0, 8),\n\t\textension\t\t\t\t\t= path.extname(sprite);\n\t\tsprite\t\t\t\t\t\t= path.join(path.dirname(sprite), path.basename(sprite, extension) + hash + extension);\n\t\tthis.data.sprite\t\t\t= path.relative(this._cssDest, sprite).split(path.sep).join('/');\n\t\tif (this.config.example) {\n\t\t\tthis.data.example\t\t= path.relative(path.dirname(this.config.example.dest), sprite).split(path.sep).join('/');\n\t\t}\n\t}\n\n\treturn sprite;\n};\n\n/**\n * Module export\n */\nmodule.exports = SVGSpriteBase;\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/mode/css.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _\t\t\t\t\t\t\t\t= require('lodash');\nvar pluck\t\t\t\t\t\t\t= require('lodash.pluck');\nvar util\t\t\t\t\t\t\t= require('util');\nvar SVGSpriteBase\t\t\t\t\t= require('./base');\nvar SVGSprite\t\t\t\t\t\t= require('../sprite');\n\n/**\n * CSS sprite\n *\n * @param {SVGSpriter} spriter\t\tSVG spriter\n * @param {Object} config\t\t\tConfiguration\n * @param {Object} data\t\t\t\tBase data\n * @param {String} key\t\t\t\tMode key\n */\nfunction SVGSpriteCss(spriter, config, data, key) {\n\tSVGSpriteBase.apply(this, [spriter, config, data, key]);\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriteCss.prototype = _.create(SVGSpriteBase.prototype, {\n\tconstructor\t\t\t\t\t\t: SVGSpriteCss,\n\tmode\t\t\t\t\t\t\t: SVGSpriteBase.prototype.MODE_CSS,\n\ttmpl\t\t\t\t\t\t\t: 'css',\n\n\tLAYOUT_VERTICAL\t\t\t\t\t: 'vertical',\n\tLAYOUT_HORIZONTAL\t\t\t\t: 'horizontal',\n\tLAYOUT_DIAGONAL\t\t\t\t\t: 'diagonal',\n\tLAYOUT_PACKED\t\t\t\t\t: 'packed'\n});\n\n/**\n * Initialization (non-CSS modes)\n *\n * @return {void}\n */\nSVGSpriteCss.prototype._init = function() {\n\n\t// Prepare the dimension suffix\n\tif (this.config.dimensions && (this.config.dimensions !== true)) {\n\t\tthis.config.dimensions\t\t= /%s/g.test((this.config.dimensions || '').split('%%').join('')) ? util.format(this.config.dimensions, this.config.prefix) : (this.config.prefix + this.config.dimensions);\n\t}\n\n\t// Determine the mixin mode and name\n\tswitch(typeof this.config.mixin) {\n\n\t\t// String: Use the given string as mixin name\n\t\tcase 'string':\n\t\t\tthis.config.mixin\t\t= this.config.mixin.trim().length ? this.config.mixin.trim() : null;\n\t\t\tbreak;\n\n\t\t// Boolean: Use the common CSS class name (if any)\n\t\tcase 'boolean':\n\t\t\tthis.config.mixin\t\t= !!this.config.common ? this.config.common : null;\n\t\t\tbreak;\n\n\t\t// Default: Don't use mixin\n\t\tdefault:\n\t\t\tthis.config.mixin\t\t= null;\n\t\t\tbreak;\n\t}\n\n\t// Refine the base data\n\tthis.data\t\t\t\t\t\t= _.assign(this.data, {\n\t\thasCommon\t\t\t\t\t: !!this.config.common,\n\t\tcommon\t\t\t\t\t\t: this.config.common,\n\t\tcommonName\t\t\t\t\t: this.config.common || 'svg-common',\n\t\thasMixin\t\t\t\t\t: !!this.config.mixin,\n\t\tmixinName\t\t\t\t\t: this.config.mixin,\n\t\tincludeDimensions\t\t\t: !!this.config.dimensions,\n\t\tspriteWidth\t\t\t\t\t: 0,\n\t\tspriteHeight\t\t\t\t: 0\n\t});\n\n\t// Determine if this sprite accepts displaced shape copies\n\tthis._displaceable\t\t\t\t= ([this.LAYOUT_VERTICAL, this.LAYOUT_HORIZONTAL].indexOf(this.config.layout) >= 0);\n\n\tthis._precision                 = (+this.config.svg.precision >= 0) ? Math.pow(10, +this.config.svg.precision) : null;\n};\n\n/**\n * Layout the sprite\n *\n * @param {Array} files\t\t\t\tFiles\n * @param {Function} cb\t\t\t\tCallback\n * @return {void}\n */\nSVGSpriteCss.prototype.layout = function(files, cb) {\n\n\t// Layout the sprite\n\tvar config\t\t\t\t\t\t= this._layout();\n\n\t// Build the sprite SVG file\n\tfiles.sprite\t\t\t\t\t= this._buildSVG(config.xmlDeclaration || '', config.doctypeDeclaration || '');\n\tthis._spriter.verbose('Created «%s» SVG sprite file («%s» mode)', this.key, this.mode);\n\n\t// Build the configured CSS resources\n\tthis._buildCSSResources(files, function(error) {\n\n\t\t// In case of errors: Break\n\t\tif (error) {\n\t\t\tcb(error);\n\n\t\t// Else: Build the HTML example\n\t\t} else {\n\t\t\tthis._buildHTMLExample(files, cb);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Layout the sprite (internal)\n *\n * @return {Object}\t\t\t\t\tSprite configuration\n */\nSVGSpriteCss.prototype._layout = function() {\n\n\t// Build a map of shape IDs that need to get a ':regular' pseudo class in CSS\n\tvar pseudoShapeMap\t\t\t\t= {};\n\tthis._spriter._shapes.forEach(function(shape) {\n\t\tpseudoShapeMap[shape.base]\t= pseudoShapeMap[shape.base] || !!shape.state;\n\t}, this._spriter);\n\n\t// Layout the sprite\n\tthis[(this.config.layout === this.LAYOUT_PACKED) ? '_layoutBinPacked' : '_layoutSimple'](pseudoShapeMap);\n\n\t// Refine the shape data\n\tvar xmlDeclaration\t\t\t\t= null,\n\tdoctypeDeclaration\t\t\t\t= null,\n\tpositionMap\t\t\t\t\t\t= {};\n\tthis.data.shapes.forEach(function(shape, index) {\n\n\t\t// Skip non-master shapes for all but orthogonal layouts\n\t\tif (this._displaceable || !shape.master) {\n\t\t\txmlDeclaration\t\t\t= xmlDeclaration || this._spriter._shapes[index].xmlDeclaration;\n\t\t\tdoctypeDeclaration\t\t= doctypeDeclaration || this._spriter._shapes[index].doctypeDeclaration;\n\t\t\tvar x, y;\n\n\t\t\t// For vertical layouts: Set the horizontal alignment\n\t\t\tif (this.config.layout === this.LAYOUT_VERTICAL) {\n\t\t\t\tx\t\t\t\t\t= this._spriter._shapes[index].align * 100;\n\t\t\t\tshape.position.absolute.x\t\t= this._spriter._shapes[index]._round(- x * (this.data.spriteWidth - shape.width.outer) / 100);\n\n\t\t\t// Else: Determine the relative horizontal position\n\t\t\t} else {\n\t\t\t\tx\t\t\t\t\t= shape.position.absolute.x ? (100 * Math.abs(shape.position.absolute.x) / (this.data.spriteWidth - shape.width.outer)) : 0;\n\t\t\t}\n\n\t\t\t// For horizontal layouts: Set the vertical alignment\n\t\t\tif (this.config.layout === this.LAYOUT_HORIZONTAL) {\n\t\t\t\ty\t\t\t\t\t= this._spriter._shapes[index].align * 100;\n\t\t\t\tshape.position.absolute.y\t\t= this._spriter._shapes[index]._round(- y * (this.data.spriteHeight - shape.height.outer) / 100);\n\n\t\t\t// Else: Determine the relative vertical position\n\t\t\t} else {\n\t\t\t\ty\t\t\t\t\t= shape.position.absolute.y ? (100 * Math.abs(shape.position.absolute.y) / (this.data.spriteHeight - shape.height.outer)) : 0;\n\t\t\t}\n\n\t\t\t// Set the relative position\n\t\t\tshape.position.relative\t= {\n\t\t\t\tx\t\t\t\t\t: this._round(x),\n\t\t\t\ty\t\t\t\t\t: this._round(y),\n\t\t\t\txy\t\t\t\t\t: this._addUnit(this._round(x), '%') + ' ' + this._addUnit(this._round(y), '%')\n\t\t\t};\n\n\n\t\t\tif (!shape.master) {\n\t\t\t\tpositionMap[this._spriter._shapes[index].id]\t= _.pick(shape.position.absolute, ['x', 'y']);\n\t\t\t}\n\n\t\t\t// Rework zero-valued positions\n\t\t\tvar svg\t\t\t\t\t= shape.svg.split('>');\n\n\t\t\t// Replace zero-valued x-positions\n\t\t\tvar svgX\t\t\t\t= svg[0].split(' x=\"0\"');\n\t\t\tif (svgX.length > 1) {\n\t\t\t\tx\t\t\t\t\t= shape.master ? (shape.position.absolute.x - positionMap[shape.master].x) : shape.position.absolute.x;\n\t\t\t\tsvg[0]\t\t\t\t= svgX.join(x ? (' x=\"' + (-x) + '\"') : '');\n\t\t\t}\n\n\t\t\t// Replace zero-valued y-positions\n\t\t\tvar svgY\t\t\t\t= svg[0].split(' y=\"0\"');\n\t\t\tif (svgY.length > 1) {\n\t\t\t\ty\t\t\t\t\t= shape.master ? (shape.position.absolute.y - positionMap[shape.master].y) : shape.position.absolute.y;\n\t\t\t\tsvg[0]\t\t\t\t= svgY.join(y ? (' y=\"' + (-y) + '\"') : '');\n\t\t\t}\n\n\t\t\tshape.svg\t\t\t\t= svg.join('>');\n\t\t}\n\n\t}, this);\n\n\t// Remove all non-master shapes for non-displaceable sprites\n\tif (!this._displaceable) {\n\t\tthis.data.shapes\t\t\t\t= _.reject(this.data.shapes, function(shape){ return !!shape.master; });\n\t}\n\n\treturn {\n\t\txmlDeclaration\t\t\t\t: xmlDeclaration,\n\t\tdoctypeDeclaration\t\t\t: doctypeDeclaration\n\t};\n};\n\n/**\n * Layout a simple CSS sprite\n *\n * @param {Object} pseudoShapeMap\tPseudo shape map\n * @return {SVGSpriteCss}\t\t\tSelf reference\n */\nSVGSpriteCss.prototype._layoutSimple = function(pseudoShapeMap) {\n\tthis._spriter._shapes.forEach(function(shape, index){\n\t\tif (this._displaceable || !shape.master) {\n\t\t\tthis._addShapeToSimpleCssSprite(shape, pseudoShapeMap[shape.base], index, !index + (index === this._spriter._shapes.length - 1) * 2);\n\t\t}\n\t}, this);\n\treturn this;\n};\n\n/**\n * Add a single shape to the simple CSS sprite\n *\n * @param {SVGShape} shape\t\t\tShape\n * @param {Boolean} needsRegular\tNeeds a :regular pseudo class in CSS\n * @param {Number} index\t\t\tIndex\n * @param {Number} position\t\t\tPosition bits\n */\nSVGSpriteCss.prototype._addShapeToSimpleCssSprite = function(shape, needsRegular, index, position) {\n\tvar dimensions\t\t\t\t\t= shape.getDimensions(),\n\t\trootAttributes\t\t\t\t= {id: shape.id},\n\t\tpositionX\t\t\t\t\t= 0,\n\t\tpositionY\t\t\t\t\t= 0;\n\n\tswitch (this.config.layout) {\n\n\t\t// Horizontal sprite arrangement\n\t\tcase this.LAYOUT_HORIZONTAL:\n\t\t\trootAttributes.y\t\t= 0;\n\t\t\trootAttributes.x\t\t= this.data.spriteWidth;\n\t\t\tpositionX\t\t\t\t= -this.data.spriteWidth;\n\n\t\t\tthis.data.spriteWidth\t= Math.ceil(this.data.spriteWidth + dimensions.width);\n\t\t\tthis.data.spriteHeight\t= Math.max(this.data.spriteHeight, dimensions.height);\n\t\t\tbreak;\n\n\t\t// Diagonal sprite arrangement\n\t\tcase this.LAYOUT_DIAGONAL:\n\t\t\trootAttributes.x\t\t= this.data.spriteWidth;\n\t\t\trootAttributes.y\t\t= this.data.spriteHeight;\n\t\t\tpositionX\t\t\t\t= -this.data.spriteWidth;\n\t\t\tpositionY\t\t\t\t= -this.data.spriteHeight;\n\n\t\t\tthis.data.spriteWidth\t= Math.ceil(this.data.spriteWidth + dimensions.width);\n\t\t\tthis.data.spriteHeight\t= Math.ceil(this.data.spriteHeight + dimensions.height);\n\t\t\tbreak;\n\n\t\t// Vertical sprite arrangement (default)\n\t\tdefault:\n\t\t\trootAttributes.x\t\t= 0;\n\t\t\trootAttributes.y\t\t= this.data.spriteHeight;\n\t\t\tpositionY\t\t\t\t= -this.data.spriteHeight;\n\n\t\t\tthis.data.spriteWidth\t= Math.max(this.data.spriteWidth, dimensions.width);\n\t\t\tthis.data.spriteHeight\t= Math.ceil(this.data.spriteHeight + dimensions.height);\n\t}\n\n\tthis._addShapeToCSSSprite(shape, needsRegular, index, position, this._refineRootAttributes(shape, index, rootAttributes), positionX, positionY);\n};\n\n/**\n * Layout a binpacked CSS sprite\n *\n * @see http://codeincomplete.com/posts/2011/5/7/bin_packing/\n * @param {Object} pseudoShapeMap\tPseudo shape map\n * @return {SVGSpriteCss}\t\t\tSelf reference\n */\nSVGSpriteCss.prototype._layoutBinPacked = function(pseudoShapeMap) {\n\tvar SVGSpriteCssPacker\t\t\t= require('./css/packer'),\n\tpacker\t\t\t\t\t\t\t= new SVGSpriteCssPacker(this._spriter._shapes),\n\tpositions\t\t\t\t\t\t= packer.fit();\n\n\t// Run through all shapes and add them to the sprite\n\tthis._spriter._shapes.forEach(function(shape, index){\n\n\t\t// Skip non-master shapes\n\t\tif (!shape.master) {\n\t\t\tvar dimensions\t\t\t= shape.getDimensions(),\n\t\t\tposition\t\t\t\t= positions[index],\n\t\t\trootAttributes\t\t\t= {id: shape.id, x: position.x, y: position.y};\n\n\t\t\tthis.data.spriteWidth\t= Math.max(this.data.spriteWidth, Math.ceil(position.x + dimensions.width));\n\t\t\tthis.data.spriteHeight\t= Math.max(this.data.spriteHeight, Math.ceil(position.y + dimensions.height));\n\n\t\t\tthis._addShapeToCSSSprite(shape, pseudoShapeMap[shape.base], index, !index + (index === this._spriter._shapes.length - 1) * 2, this._refineRootAttributes(shape, index, rootAttributes), -position.x, -position.y);\n\t\t}\n\t}, this);\n\n\treturn this;\n};\n\n/**\n * Refine the root attributes set on each nested shape\n *\n * @param {SVGShape} shape\t\t\tShape\n * @param {Number} index\t\t\tIndex\n * @param {Object} rootAttributes\tRoot element attributes\n * @return {Object}\t\t\t\t\tRefined root element attributes\n */\nSVGSpriteCss.prototype._refineRootAttributes = function(shape, index, rootAttributes) {\n\treturn rootAttributes;\n};\n\n/**\n * Add a single shape to a CSS sprite\n *\n * @param {SVGShape} shape\t\t\tShape\n * @param {Boolean} needsRegular\tNeeds a :regular pseudo class in CSS\n * @param {Number} index\t\t\tIndex\n * @param {Number} position\t\t\tPosition bits\n * @param {Number} rootAttributes\tRoot element attributes\n * @param {Number} positionX\t\tHorizontal position within the sprite\n * @param {Number} positionY\t\tVertical position within the sprite\n */\nSVGSpriteCss.prototype._addShapeToCSSSprite = function(shape, needsRegular, index, position, rootAttributes, positionX, positionY) {\n\n\t// Prepare the selectors\n\tvar selector\t\t\t\t\t= {\n\t\tshape\t\t\t\t\t\t: (needsRegular || shape.state) ? [{\n\t\t\texpression\t\t\t\t: util.format(this.config.prefix, shape.base + (shape.state ? (':' + shape.state) : '')),\n\t\t\traw\t\t\t\t\t\t: util.format(this.config.prefix, shape.base + (shape.state ? (':' + shape.state) : '')),\n\t\t\tfirst\t\t\t\t\t: true,\n\t\t\tlast\t\t\t\t\t: false\n\t\t}, {\n\t\t\texpression\t\t\t\t: util.format(this.config.prefix, shape.base + '\\\\:' + (shape.state || 'regular')),\n\t\t\traw\t\t\t\t\t\t: util.format(this.config.prefix, shape.base + ':' + (shape.state || 'regular')),\n\t\t\tfirst\t\t\t\t\t: false,\n\t\t\tlast\t\t\t\t\t: true\n\t\t}] : [{\n\t\t\texpression\t\t\t\t: util.format(this.config.prefix, shape.base),\n\t\t\traw\t\t\t\t\t\t: util.format(this.config.prefix, shape.base),\n\t\t\tfirst\t\t\t\t\t: true,\n\t\t\tlast\t\t\t\t\t: true\n\t\t}]\n\t};\n\n\t// Prepare the dimension properties\n\tif (this.config.dimensions !== true) {\n\t\tselector.dimensions\t\t\t= shape.state ? [{\n\t\t\texpression\t\t\t\t: util.format(this.config.dimensions, shape.base) + ':' + shape.state,\n\t\t\traw\t\t\t\t\t\t: util.format(this.config.dimensions, shape.base) + ':' + shape.state,\n\t\t\tfirst\t\t\t\t\t: true,\n\t\t\tlast\t\t\t\t\t: false\n\t\t}, {\n\t\t\texpression\t\t\t\t: util.format(this.config.dimensions, shape.base + '\\\\:' + shape.state),\n\t\t\traw\t\t\t\t\t\t: util.format(this.config.dimensions, shape.base + ':' + shape.state),\n\t\t\tfirst\t\t\t\t\t: false,\n\t\t\tlast\t\t\t\t\t: true\n\t\t}] : [{\n\t\t\texpression\t\t\t\t: util.format(this.config.dimensions, shape.base),\n\t\t\traw\t\t\t\t\t\t: util.format(this.config.dimensions, shape.base),\n\t\t\tfirst\t\t\t\t\t: true,\n\t\t\tlast\t\t\t\t\t: true\n\t\t}];\n\t}\n\n\t// Register the SVG parameters\n\t_.assign(this.data.shapes[index], {\n\t\tfirst\t\t\t\t\t\t: !!(position & 1),\n\t\tlast\t\t\t\t\t\t: !!(position & 2),\n\t\tposition\t\t\t\t\t: {\n\t\t\tabsolute\t\t\t\t: {\n\t\t\t\tx\t\t\t\t\t: positionX,\n\t\t\t\ty\t\t\t\t\t: positionY,\n\t\t\t\txy\t\t\t\t\t: this._addUnit(positionX, 'px') + ' ' + this._addUnit(positionY, 'px')\n\t\t\t}\n\t\t},\n\t\tselector\t\t\t\t\t: selector,\n\t\tdimensions\t\t\t\t\t: {\n\t\t\tinline\t\t\t\t\t: (this.config.dimensions === true),\n\t\t\textra\t\t\t\t\t: !!(_.isString(this.config.dimensions) && this.config.dimensions.length)\n\t\t}\n\t});\n\n\t// Create the SVG getter/setter\n\tObject.defineProperty(this.data.shapes[index], '_svg', {\n\t    enumerable\t\t\t\t\t: false,\n\t    writable\t\t\t\t\t: true\n\t});\n\tthis.data.shapes[index].__defineGetter__('svg', function() {\n\t\treturn this._svg || shape.getSVG(true, function(shapeDOM) {\n\t\t\tfor (var r in rootAttributes) {\n\t\t\t\tshapeDOM.setAttribute(r, rootAttributes[r]);\n\t\t\t}\n\t\t});\n\t});\n\tthis.data.shapes[index].__defineSetter__('svg', function(svg) {\n\t\tthis._svg\t\t\t\t\t= svg;\n\t});\n};\n\n/**\n * Build the CSS sprite\n *\n * @param {String} xmlDeclaration\t\t\tXML declaration\n * @param {String} doctypeDeclaration\t\tDoctype declaration\n * @return {File}\t\t\t\t\t\t\tSVG sprite file\n */\nSVGSpriteCss.prototype._buildSVG = function(xmlDeclaration, doctypeDeclaration) {\n\tvar rootAttributes\t\t\t\t= _.extend(\n\t\t{},\n\t\tthis.config.svg.rootAttributes,\n\t\tthis.config.svg.dimensionAttributes ? {\n\t\t\twidth\t\t\t\t\t: this.data.spriteWidth,\n\t\t\theight\t\t\t\t\t: this.data.spriteHeight\n\t\t} : {},\n\t\t{\n\t\t\tviewBox\t\t\t\t\t: '0 0 ' + this.data.spriteWidth + ' ' + this.data.spriteHeight\n\t\t}\n\t),\n\tsvg\t\t\t\t\t\t\t\t= new SVGSprite(this.declaration(this.config.svg.xmlDeclaration, xmlDeclaration), this.declaration(this.config.svg.doctypeDeclaration, doctypeDeclaration), rootAttributes, true, this.config.svg.transform);\n\tsvg.add(pluck(this.data.shapes, 'svg'));\n\n\treturn svg.toFile(this._spriter.config.dest, this._addCacheBusting(svg));\n};\n\n/**\n * Round a number considering the given decimal place precision for CSS positioning values\n *\n * @param {Number} n            Number\n * @return {Number}             Rounded number\n */\nSVGSpriteCss.prototype._round = function(n) {\n\treturn this._precision ? (Math.round(n * this._precision) / this._precision) : n;\n};\n\n/**\n * Module export\n */\nmodule.exports = SVGSpriteCss;\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/mode/defs.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _\t\t\t\t\t\t\t\t= require('lodash');\nvar pluck\t\t\t\t\t\t\t= require('lodash.pluck');\nvar SVGSpriteStandalone\t\t\t\t= require('./standalone');\nvar SVGSprite\t\t\t\t\t\t= require('../sprite');\n\n/**\n * <defs> sprite\n *\n * @param {SVGSpriter} spriter\t\tSVG spriter\n * @param {Object} config\t\t\tConfiguration\n * @param {Object} data\t\t\t\tBase data\n * @param {String} key\t\t\t\tMode key\n */\nfunction SVGSpriteDefs(spriter, config, data, key) {\n\tSVGSpriteStandalone.apply(this, [spriter, config, data, key]);\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriteDefs.prototype = _.create(SVGSpriteStandalone.prototype, {\n\tconstructor\t\t\t\t\t\t: SVGSpriteDefs,\n\tmode\t\t\t\t\t\t\t: SVGSpriteStandalone.prototype.MODE_DEFS\n});\n\n/**\n * Layout the sprite\n *\n * @param {Array} files\t\t\t\tFiles\n * @param {Function} cb\t\t\t\tCallback\n * @return {void}\n */\nSVGSpriteDefs.prototype.layout = function(files, cb) {\n\tthis._layout(files, cb, function(shape, dataShape /*, index*/){\n\t\tvar dimensionAttributes\t\t= shape.config.dimension.attributes;\n\n\t\t// Create the SVG getter/setter\n\t\tdataShape.__defineGetter__('svg', function() {\n\t\t\treturn this._svg || shape.getSVG(true, function(shapeDOM) {\n\t\t\t\tshapeDOM.setAttribute('id', shape.id);\n\n\t\t\t\tif (!dimensionAttributes) {\n\t\t\t\t\tshapeDOM.removeAttribute('width');\n\t\t\t\t\tshapeDOM.removeAttribute('height');\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n};\n\n/**\n * Build the CSS sprite\n *\n * @param {String} xmlDeclaration\t\t\tXML declaration\n * @param {String} doctypeDeclaration\t\tDoctype declaration\n * @return {File}\t\t\t\t\t\t\tSVG sprite file\n */\nSVGSpriteDefs.prototype._buildSVG = function(xmlDeclaration, doctypeDeclaration) {\n\tvar inline\t\t\t\t\t\t= !!this.config.inline,\n\trootAttributes\t\t\t\t\t= _.extend(\n\t\t{},\n\t\tthis.config.svg.rootAttributes\n\t),\n\tsvg\t\t\t\t\t\t\t\t= new SVGSprite(inline ? '' : this.declaration(this.config.svg.xmlDeclaration, xmlDeclaration), inline ? '' : this.declaration(this.config.svg.doctypeDeclaration, doctypeDeclaration), inline ? _.extend(\n\t\t\trootAttributes,\n\t\t\tthis.config.svg.dimensionAttributes ? {\n\t\t\t\twidth\t\t\t\t\t\t: 0,\n\t\t\t\theight\t\t\t\t\t\t: 0\n\t\t\t} : {},\n\t\t\t{\n\t\t\t\tstyle\t\t\t\t\t\t: 'position:absolute'\n\t\t\t}\n\t\t) : rootAttributes, !inline, this.config.svg.transform);\n\tsvg.add('<defs>');\n\tsvg.add(pluck(this.data.shapes, 'svg'));\n\tsvg.add('</defs>');\n\n\treturn svg.toFile(this._spriter.config.dest, this._addCacheBusting(svg));\n};\n\n/**\n * Module export\n */\nmodule.exports = SVGSpriteDefs;\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/mode/standalone.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _\t\t\t\t\t\t\t\t= require('lodash'),\nutil\t\t\t\t\t\t\t\t= require('util'),\nSVGSpriteBase\t\t\t\t\t\t= require('./base');\n\n/**\n * Base class for non-css sprites\n *\n * @param {SVGSpriter} spriter\t\tSVG spriter\n * @param {Object} config\t\t\tConfiguration\n * @param {Object} data\t\t\t\tBase data\n */\nfunction SVGSpriteStandalone(spriter, config, data) {\n\tSVGSpriteBase.apply(this, [spriter, config, data]);\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriteStandalone.prototype = _.create(SVGSpriteBase.prototype, {\n\tconstructor\t\t\t\t\t\t: SVGSpriteStandalone\n});\n\n/**\n * Initialization (non-CSS modes)\n *\n * @return {void}\n */\nSVGSpriteStandalone.prototype._init = function() {\n\n\t// Prepare the dimension suffix\n\tthis.config.dimensions\t\t\t= _.isString(this.config.dimensions) ? this.config.dimensions.trim() : '-dims';\n\tif (this.config.dimensions) {\n\t\tthis.config.dimensions\t\t= /%s/g.test((this.config.dimensions || '').split('%%').join('')) ? util.format(this.config.dimensions, this.config.prefix) : (this.config.prefix + this.config.dimensions);\n\t}\n\n\tthis.data.inline\t\t\t\t= !!this.config.inline;\n};\n\n/**\n * Layout the sprite\n *\n * @param {Array} files\t\t\t\tFiles\n * @param {Function} cb\t\t\t\tCallback\n * @param {Function} extend\t\t\tExtension callback\n * @return {void}\n */\nSVGSpriteStandalone.prototype._layout = function(files, cb, extend) {\n\n\t// Refine the shape data\n\tvar xmlDeclaration\t\t\t\t= null,\n\tdoctypeDeclaration\t\t\t\t= null;\n\tthis._spriter._shapes.forEach(function(shape, index) {\n\n\t\t// Skip non-master shapes\n\t\tif (!shape.master) {\n\t\t\txmlDeclaration\t\t\t= xmlDeclaration || shape.xmlDeclaration;\n\t\t\tdoctypeDeclaration\t\t= doctypeDeclaration || shape.doctypeDeclaration;\n\t\t\t_.assign(this.data.shapes[index], {\n\t\t\t\tselector\t\t\t: {\n\t\t\t\t\tdimensions\t\t: shape.state ? [{\n\t\t\t\t\t\texpression\t: util.format(this.config.dimensions, shape.base) + ':' + shape.state,\n\t\t\t\t\t\traw\t\t\t: util.format(this.config.dimensions, shape.base) + ':' + shape.state,\n\t\t\t\t\t\tfirst\t\t: true,\n\t\t\t\t\t\tlast\t\t: false\n\t\t\t\t\t}, {\n\t\t\t\t\t\texpression\t: util.format(this.config.dimensions, shape.base + '\\\\:' + shape.state),\n\t\t\t\t\t\traw\t\t\t: util.format(this.config.dimensions, shape.base + ':' + shape.state),\n\t\t\t\t\t\tfirst\t\t: false,\n\t\t\t\t\t\tlast\t\t: true\n\t\t\t\t\t}] : [{\n\t\t\t\t\t\texpression\t: util.format(this.config.dimensions, shape.base),\n\t\t\t\t\t\traw\t\t\t: util.format(this.config.dimensions, shape.base),\n\t\t\t\t\t\tfirst\t\t: true,\n\t\t\t\t\t\tlast\t\t: true\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t});\n\t\t\tObject.defineProperty(this.data.shapes[index], '_svg', {\n\t\t\t    enumerable\t\t\t: false,\n\t\t\t    writable\t\t\t: true\n\t\t\t});\n\t\t\tthis.data.shapes[index].__defineSetter__('svg', function(svg) {\n\t\t\t\tthis._svg\t\t\t= svg;\n\t\t\t});\n\t\t\textend(shape, this.data.shapes[index], index);\n\t\t}\n\t}, this);\n\n\t// Remove all non-master shapes\n\tthis.data.shapes\t\t\t\t= _.reject(this.data.shapes, function(shape){ return !!shape.master; });\n\n\t// Build the sprite SVG file\n\tfiles.sprite\t\t\t\t\t= this._buildSVG(xmlDeclaration || '', doctypeDeclaration || '');\n\tthis._spriter.verbose('Created «%s» SVG sprite file («%s» mode)', this.key, this.mode);\n\n\t// Build the configured CSS resources\n\tthis._buildCSSResources(files, function(error) {\n\n\t\t// In case of errors: Break\n\t\tif (error) {\n\t\t\tcb(error);\n\n\t\t// Else: Build the HTML example\n\t\t} else {\n\t\t\tthis._buildHTMLExample(files, cb);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Module export\n */\nmodule.exports = SVGSpriteStandalone;\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/mode/stack.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _\t\t\t\t\t\t\t\t= require('lodash');\nvar pluck\t\t\t\t\t\t\t= require('lodash.pluck');\nvar SVGSpriteStandalone\t\t\t\t= require('./standalone');\nvar SVGSprite\t\t\t\t\t\t= require('../sprite');\n\n/**\n * SVG stack\n * \n * @param {SVGSpriter} spriter\t\tSVG spriter\n * @param {Object} config\t\t\tConfiguration\n * @param {Object} data\t\t\t\tBase data\n * @param {String} key\t\t\t\tMode key\n */\nfunction SVGSpriteStack(spriter, config, data, key) {\n\tSVGSpriteStandalone.apply(this, [spriter, config, data, key]);\n}\n\n/**\n * Prototype\n * \n * @type {Object} \n */\nSVGSpriteStack.prototype = _.create(SVGSpriteStandalone.prototype, {\n\tconstructor\t\t\t\t\t\t: SVGSpriteStack,\n\tmode\t\t\t\t\t\t\t: SVGSpriteStandalone.prototype.MODE_STACK\n});\n\n/**\n * Initialization (non-CSS modes)\n * \n * @return {void}\n */\nSVGSpriteStack.prototype._init = function() {\n\tSVGSpriteStandalone.prototype._init.apply(this);\n\t\n\t// Determine the maximum shape dimensions\n\tthis.maxDimensions\t\t\t\t= {width: 0, height: 0};\n\tthis.data.shapes.forEach(function(shape){\n\t\tthis.maxDimensions.width\t= Math.max(this.maxDimensions.width, shape.width.outer);\n        this.maxDimensions.height\t= Math.max(this.maxDimensions.height, shape.height.outer);\n\t}, this);\n};\n\n/**\n * Layout the sprite\n * \n * @param {Array} files\t\t\t\tFiles\n * @param {Function} cb\t\t\t\tCallback\n * @return {void}\n */\nSVGSpriteStack.prototype.layout = function(files, cb) {\n\tthis._layout(files, cb, function(shape, dataShape /*, index*/){\n\t\tvar dimensionAttributes\t\t= shape.config.dimension.attributes;\n\t\t\n\t\t// Create the SVG getter/setter\n\t\tdataShape.__defineGetter__('svg', function() {\n\t\t\treturn this._svg || shape.getSVG(true, function(shapeDOM) {\n\t\t\t\tshapeDOM.setAttribute('id', shape.id);\n\t\t\t\t\n\t\t\t\tif (!dimensionAttributes) {\n\t\t\t\t\tshapeDOM.removeAttribute('width');\n\t\t\t\t\tshapeDOM.removeAttribute('height');\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n};\n\n/**\n * Build the CSS sprite\n * \n * @param {String} xmlDeclaration\t\t\tXML declaration\n * @param {String} doctypeDeclaration\t\tDoctype declaration\n * @return {File}\t\t\t\t\t\t\tSVG sprite file \n */\nSVGSpriteStack.prototype._buildSVG = function(xmlDeclaration, doctypeDeclaration) {\n\tvar rootAttributes\t\t\t\t= _.extend(\n\t\t{},\n\t\tthis.config.svg.rootAttributes,\n\t\t{\n\t\t\tviewBox\t\t\t\t\t: '0 0 ' + this.maxDimensions.width + ' ' + this.maxDimensions.height\n\t\t}\n\t),\n\tsvg\t\t\t\t\t\t\t\t= new SVGSprite(this.declaration(this.config.svg.xmlDeclaration, xmlDeclaration), this.declaration(this.config.svg.doctypeDeclaration, doctypeDeclaration), rootAttributes, true, this.config.svg.transform);\n\tsvg.add('<style>:root>svg{display:none}:root>svg:target{display:block}</style>');\n\tsvg.add(pluck(this.data.shapes, 'svg'));\n\t\n\treturn svg.toFile(this._spriter.config.dest, this._addCacheBusting(svg));\n};\n\n/**\n * Module export\n */\nmodule.exports = SVGSpriteStack;\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/mode/symbol.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _\t\t\t\t\t\t\t\t= require('lodash');\nvar pluck\t\t\t\t\t\t\t= require('lodash.pluck');\nvar SVGSpriteStandalone\t\t\t\t= require('./standalone');\nvar SVGSprite\t\t\t\t\t\t= require('../sprite');\nvar symbolAttributes\t\t\t\t= ['id', 'xml:base', 'xml:lang', 'xml:space', 'onfocusin', 'onfocusout', 'onactivate', 'onclick', 'onmousedown', 'onmouseup', 'onmouseover', 'onmousemove', 'onmouseout', 'onload', 'alignment-baseline', 'baseline-shift', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cursor', 'direction', 'display', 'dominant-baseline', 'enable-background', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'image-rendering', 'kerning', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'mask', 'opacity', 'overflow', 'pointer-events', 'shape-rendering', 'stop-color', 'stop-opacity', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'unicode-bidi', 'visibility', 'word-spacing', 'writing-mode', 'class', 'style', 'externalResourcesRequired', 'preserveAspectRatio', 'viewBox', 'aria-labelledby'];\n\n/**\n * <symbol> sprite\n *\n * @param {SVGSpriter} spriter\t\tSVG spriter\n * @param {Object} config\t\t\tConfiguration\n * @param {Object} data\t\t\t\tBase data\n * @param {String} key\t\t\t\tMode key\n */\nfunction SVGSpriteSymbol(spriter, config, data, key) {\n\tSVGSpriteStandalone.apply(this, [spriter, config, data, key]);\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriteSymbol.prototype = _.create(SVGSpriteStandalone.prototype, {\n\tconstructor\t\t\t\t\t\t: SVGSpriteSymbol,\n\tmode\t\t\t\t\t\t\t: SVGSpriteStandalone.prototype.MODE_SYMBOL\n});\n\n/**\n * Layout the sprite\n *\n * @param {Array} files\t\t\t\tFiles\n * @param {Function} cb\t\t\t\tCallback\n * @return {void}\n */\nSVGSpriteSymbol.prototype.layout = function(files, cb) {\n\tthis._layout(files, cb, function(shape, dataShape /*, index*/){\n\n\t\t// Create the SVG getter/setter\n\t\tdataShape.__defineGetter__('svg', function() {\n\t\t\treturn this._svg || shape.getSVG(true, function(shapeDOM) {\n\t\t\t\tshapeDOM.nodeName\t=\n\t\t\t\tshapeDOM.tagName\t=\n\t\t\t\tshapeDOM.localName\t= 'symbol';\n\t\t\t\tvar removeAttributes = [];\n\t\t\t\tArray.prototype.forEach.call(shapeDOM.attributes, function( attribute ){\n\t\t\t\t\tif (symbolAttributes.indexOf(attribute.name) === -1) {\n\t\t\t\t\t\tremoveAttributes.push(attribute.name);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tremoveAttributes.forEach(function(attribute){\n\t\t\t\t\tshapeDOM.removeAttribute(attribute);\n\t\t\t\t})\n\t\t\t\tshapeDOM.setAttribute('id', shape.id);\n\t\t\t});\n\t\t});\n\t});\n};\n\n/**\n * Build the CSS sprite\n *\n * @param {String} xmlDeclaration\t\t\tXML declaration\n * @param {String} doctypeDeclaration\t\tDoctype declaration\n * @return {File}\t\t\t\t\t\t\tSVG sprite file\n */\nSVGSpriteSymbol.prototype._buildSVG = function(xmlDeclaration, doctypeDeclaration) {\n\tvar inline\t\t\t\t\t\t= !!this.config.inline,\n\trootAttributes\t\t\t\t\t= _.extend(\n\t\t{},\n\t\tthis.config.svg.rootAttributes\n\t),\n\tsvg\t\t\t\t\t\t\t\t= new SVGSprite(inline ? '' : this.declaration(this.config.svg.xmlDeclaration, xmlDeclaration), inline ? '' : this.declaration(this.config.svg.doctypeDeclaration, doctypeDeclaration), inline ? _.extend(\n\t\t\trootAttributes,\n\t\t\tthis.config.svg.dimensionAttributes ? {\n\t\t\t\twidth\t\t\t\t\t: 0,\n\t\t\t\theight\t\t\t\t\t: 0\n\t\t\t} : {}, {\n\t\t\t\tstyle\t\t\t\t\t: 'position:absolute'\n\t\t\t}\n\t\t) : rootAttributes, !inline, this.config.svg.transform);\n\tsvg.add(pluck(this.data.shapes, 'svg'));\n\n\treturn svg.toFile(this._spriter.config.dest, this._addCacheBusting(svg));\n};\n\n/**\n * Module export\n */\nmodule.exports = SVGSpriteSymbol;\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/mode/view.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _\t\t\t\t\t\t\t\t= require('lodash'),\nSVGSpriteStandalone\t\t\t\t\t= require('./standalone'),\nSVGSpriteCss\t\t\t\t\t\t= require('./css'),\nSVGSprite\t\t\t\t\t\t\t= require('../sprite');\n\n/**\n * <view> sprite\n *\n * @param {SVGSpriter} spriter\t\tSVG spriter\n * @param {Object} config\t\t\tConfiguration\n * @param {Object} data\t\t\t\tBase data\n * @param {String} key\t\t\t\tMode key\n */\nfunction SVGSpriteView(spriter, config, data, key) {\n\tSVGSpriteCss.apply(this, [spriter, config, data, key]);\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriteView.prototype = _.create(SVGSpriteCss.prototype, {\n\tconstructor\t\t\t\t\t\t: SVGSpriteView,\n\tmode\t\t\t\t\t\t\t: SVGSpriteCss.prototype.MODE_VIEW,\n\n\t_initData\t\t\t\t\t\t: SVGSpriteStandalone.prototype._initData\n});\n\n/**\n * Refine the root attributes set on each nested shape\n *\n * @param {SVGShape} shape\t\t\tShape\n * @param {Number} index\t\t\tIndex\n * @param {Object} rootAttributes\tRoot element attributes\n * @return {Object}\t\t\t\t\tRefined root element attributes\n */\nSVGSpriteView.prototype._refineRootAttributes = function(shape, index, rootAttributes) {\n\n\t// If it's the master shape multiple displaced copies\n\tif (this._displaceable) {\n\t\tif (shape.master) {\n\t\t\tdelete rootAttributes.id;\n\t\t\trootAttributes['xlink:href']\t= '#' + shape.master.id + '-';\n\t\t} else {\n\t\t\trootAttributes.id\t\t\t\t+= '-';\n\t\t}\n\n\t// Else: Remove the ID attribute\n\t} else {\n\t\tdelete rootAttributes.id;\n\t}\n\n\treturn rootAttributes;\n};\n\n/**\n * Build the CSS sprite\n *\n * @param {String} xmlDeclaration\t\t\tXML declaration\n * @param {String} doctypeDeclaration\t\tDoctype declaration\n * @return {File}\t\t\t\t\t\t\tSVG sprite file\n */\nSVGSpriteView.prototype._buildSVG = function(xmlDeclaration, doctypeDeclaration) {\n\tvar rootAttributes\t\t\t\t= _.extend(\n\t\t{},\n\t\tthis.config.svg.rootAttributes,\n\t\tthis.config.svg.dimensionAttributes ? {\n\t\t\twidth\t\t\t\t\t: this.data.spriteWidth,\n\t\t\theight\t\t\t\t\t: this.data.spriteHeight\n\t\t} : {},\n\t\t{\n\t\t\tviewBox\t\t\t\t\t: '0 0 ' + this.data.spriteWidth + ' ' + this.data.spriteHeight\n\t\t}\n\t),\n\tsvg\t\t\t\t\t\t\t\t= new SVGSprite(this.declaration(this.config.svg.xmlDeclaration, xmlDeclaration), this.declaration(this.config.svg.doctypeDeclaration, doctypeDeclaration), rootAttributes, true, this.config.svg.transform);\n\tthis.data.shapes.forEach(function(shape) {\n\t\tvar viewBox\t\t\t\t\t= [-shape.position.absolute.x, -shape.position.absolute.y, shape.width.outer, shape.height.outer];\n\t\tsvg.add('<view id=\"' + shape.name + '\" viewBox=\"' + viewBox.join(' ') + '\"/>');\n\t\tsvg.add(shape.svg);\n\t});\n\n\treturn svg.toFile(this._spriter.config.dest, this._addCacheBusting(svg));\n};\n\n/**\n * Module export\n */\nmodule.exports = SVGSpriteView;\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/shape/dimensions.phantom.js":"'use strict';\n\n/* jshint -W117 */\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar system = require('system');\n\nif (system.args.length !== 3) {\n    console.error('Usage: dimensions.phantom.js svg path');\n\tphantom.exit();\n} else {\n\tvar page\t\t\t= require('webpage').create();\n\tvar svg\t\t\t\t= system.args[1];\n\tpage.setContent('<svg xmlns=\"http://www.w3.org/2000/svg\"><svg ' + svg.substr(svg.toLowerCase().indexOf('<svg') + 4) + '</svg>', system.args[2]);\n\tconsole.log(JSON.stringify(page.evaluate(function() {\n\t\treturn document.getElementsByTagName('svg')[1].getBoundingClientRect();\n\t})));\n}\n\nphantom.exit();\n"}