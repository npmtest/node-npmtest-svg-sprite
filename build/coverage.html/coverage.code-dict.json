{"/home/travis/build/npmtest/node-npmtest-svg-sprite/test.js":"/* istanbul instrument in package npmtest_svg_sprite */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/lib.npmtest_svg_sprite.js":"/* istanbul instrument in package npmtest_svg_sprite */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_svg_sprite = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_svg_sprite = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-svg-sprite && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_svg_sprite */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_svg_sprite\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_svg_sprite.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_svg_sprite.rollup.js'] =\n            local.assetsDict['/assets.npmtest_svg_sprite.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_svg_sprite.__dirname +\n                    '/lib.npmtest_svg_sprite.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE.txt\n */\n\nvar CONFIG\t\t\t\t\t= require('./svg-sprite/config');\nvar QUEUE\t\t\t\t\t= require('./svg-sprite/queue');\nvar SVGO\t\t\t\t\t= require('./svg-sprite/transform/svgo');\nvar LAYOUTER\t\t\t\t= require('./svg-sprite/layouter');\nvar _\t\t\t\t\t\t= require('lodash');\nvar pluck\t\t\t\t\t= require('lodash.pluck');\nvar path\t\t\t\t\t= require('path');\nvar File\t\t\t\t\t= require('vinyl');\nvar events\t\t\t\t\t= require('events');\nvar async\t\t\t\t\t= require('async');\nvar os \t\t\t\t\t\t= require('os');\nvar pretty\t\t\t\t\t= require('prettysize');\nvar util\t\t\t\t\t= require('util');\n\n/**\n * SVGSpriter class\n *\n * @param {Object} config\t\t\t\tConfiguration\n */\nfunction SVGSpriter(config) {\n\tthis.config\t\t\t\t= new CONFIG(config);\n\tthis._queue\t\t\t\t= new QUEUE(this);\n\tthis._shapes\t\t\t= [];\n\tthis._shapeTransformers\t= {svgo: SVGO};\n\tthis._compileQueue\t\t= [];\n\tthis._shapesDest\t\t= [];\n\n\tevents.EventEmitter.call(this);\n\n\tthis._queue.on('empty', this._compile.bind(this));\n\tthis._queue.on('empty', this._getShapes.bind(this));\n\tthis.on('compiled', this._compile.bind(this));\n\n\tthis.info('Created spriter instance');\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriter.prototype = Object.create(events.EventEmitter.prototype);\n\n/**\n * SVG shapes making up the sprites\n *\n * @type {Array}\n */\nSVGSpriter.prototype._shapes = [];\n\n/**\n * Namespace powers\n *\n * @type {Array}\n */\nSVGSpriter.prototype._namespacePow = [];\n\n/**\n * Add an SVG shape to the sprites\n *\n * @param {File|String} file\t\t\tVinyl file object or absolute file path\n * @param {String} name\t\t\t\t\tName part of the file path\n * @param {String} svg\t\t\t\t\tSVG content\n * @return {SVGSpriter}\t\t\t\t\tSelf reference\n * @throws {Error}\t\t\t\t\t\tIn case an invalid file should be added\n */\nSVGSpriter.prototype.add = function(file, name, svg) {\n\n\t// If no vinyl file object has been given\n\tif (!this._isVinylFile(file)) {\n\t\tfile\t\t\t\t= _.trim(file);\n\n\t\t// If the name part of the file path is absolute\n\t\tif (name && path.isAbsolute(name)) {\n\t\t\terror\t\t\t= util.format('SVGSpriter.add: \"%s\" is not a valid relative file name', name);\n\n\t\t// Else\n\t\t} else {\n\t\t\tname\t\t\t= _.trimStart(_.trim(name), path.sep + '.') || path.basename(file);\n\t\t\tsvg\t\t\t\t= _.trim(svg);\n\n\t\t\t// Argument validation\n\t\t\tvar error\t\t= null;\n\t\t\tif (arguments.length < 3) {\n\t\t\t\terror\t\t= 'SVGSpriter.add: You must provide 3 arguments';\n\t\t\t}\n\t\t\tif (!file.length) {\n\t\t\t\terror\t\t= util.format('SVGSpriter.add: \"%s\" is not a valid absolute file name', file);\n\t\t\t}\n\t\t\tif (!name.length) {\n\t\t\t\terror\t\t= util.format('SVGSpriter.add: \"%s\" is not a valid relative file name', name);\n\t\t\t}\n\t\t\tif (!svg.length) {\n\t\t\t\terror\t\t= 'SVGSpriter.add: You must provide SVG contents';\n\t\t\t}\n\t\t\tif (file.substr(-name.length) !== name) {\n\t\t\t\terror\t\t= util.format('SVGSpriter.add: \"%s\" is not the local part of \"%s\"', name, file);\n\t\t\t}\n\t\t}\n\n\t\t// In case of an error: Throw it!\n\t\tif (error) {\n\t\t\tvar e\t\t\t= new Error(error);\n\t\t\te.name\t\t\t= 'ArgumentError';\n\t\t\te.errno\t\t\t= 1419945903;\n\t\t\tthis.error(error, e);\n\t\t\tthrow e;\n\t\t}\n\n\t\t// Instanciate a vinyl file\n\t\tfile\t\t\t= new File({\n\t\t\tbase\t\t: file.substring(0, file.length - name.length),\n\t\t\tpath\t\t: file,\n\t\t\tcontents\t: new Buffer(svg)\n\t\t});\n\t}\n\n\tfile.base\t\t\t= path.resolve(file.base);\n\n\t// Add the shape to the internal processing queue\n\tthis._queue.add(file);\n\n\treturn this;\n};\n\n/**\n * Duck-typing check for vinyl file objects\n *\n * This check is necessary as singletons don't work cross-module and `instanceof` fails in these situations.\n *\n * @param {Mixed} file\t\t\t\t\tArbitrary parameter\n * @return {Boolean}\t\t\t\t\tParameter is a vinyl file object\n */\nSVGSpriter.prototype._isVinylFile = function(file) {\n\treturn _.isObject(file) && ((file instanceof File) || ((file.constructor.name === 'File') && (['path', 'contents', 'relative'].filter(function(property){ return property in this; }, file).length === 3)));\n};\n\n/**\n * Transform a single shape\n *\n * @param {SVGShape} shape\t\t\t\tShape\n * @param {Function} cb\t\t\t\t\tCallback\n */\nSVGSpriter.prototype._transformShape = function(shape, cb) {\n\tvar tasks\t\t\t\t\t= [],\n\tthat\t\t\t\t\t\t= this,\n\tcreateTransformTask\t\t\t= function(transform){\n\n\t\t// If it's a custom transformer\n\t\tif (_.isFunction(transform[1])) {\n\t\t\treturn function() {\n\t\t\t\ttransform[1](shape, that, arguments[arguments.length - 1]);\n\t\t\t};\n\n\t\t// Else if it's a registered transformer\n\t\t} else if ((transform[0] in that._shapeTransformers) && _.isObject(transform[1])) {\n\t\t\treturn function() {\n\t\t\t\tthat._shapeTransformers[transform[0]](shape, transform[1], that, arguments[arguments.length - 1]);\n\t\t\t};\n\n\t\t// Else: Break\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\n\t};\n\n\t// Run through all configured transforms\n\tfor (var t = 0, task; t < this.config.shape.transform.length; ++t) {\n\t\ttask\t\t\t\t\t= createTransformTask(this.config.shape.transform[t]);\n\n\t\tif (task) {\n\t\t\ttasks.push(task);\n\t\t}\n\t}\n\n\tasync.waterfall(tasks, function(error){\n\t\tcb(error);\n\t});\n};\n\n/**\n * Compile the sprite & additional resources\n *\n * @param {Object} config\t\t\t\tConfiguration\n * @param {Function} cb\t\t\t\t\tCallback\n */\nSVGSpriter.prototype.compile = function() {\n\tvar args\t\t\t\t\t= _.toArray(arguments),\n\tconfig\t\t\t\t\t\t= _.isPlainObject(args[0]) ? this.config.filter(args.shift()) : _.clone(this.config.mode, true),\n\tcb\t\t\t\t\t\t\t= _.isFunction(args[0]) ? args.shift() : function(error){ throw error; };\n\n\t// Schedule a compilation run\n\tthis._compileQueue.push([config, cb]);\n\tthis._compile();\n};\n\n/**\n * Run the next compile task\n */\nSVGSpriter.prototype._compile = function() {\n\n\t// If the shape queue is not currently active\n\tif (!this._queue.active && this._compileQueue.length) {\n\t\tvar that \t\t\t\t= this;\n\t\tvar args\t\t\t\t= this._compileQueue.shift();\n\n\t\t// If this is a modeless run\n\t\tif (args[0] === {}) {\n\t\t\tvar files\t\t\t= {};\n\n\t\t\t// Add intermediate SVG files\n\t\t\tif (that.config.shape.dest) {\n\t\t\t\tfiles.shapes\t= that._getShapeFiles(that.config.shape.dest);\n\t\t\t\tthat.verbose('Returning %d intermediate SVG files', files.shapes.length);\n\t\t\t}\n\n\t\t\tthat._logStats(files);\n\t\t\targs[1](null, files, {});\n\n\t\t// Else\n\t\t} else {\n\t\t\tvar masterShapes\t\t= _.reject(this._shapes, function(shape) { return !!shape.master; }).length;\n\t\t\tthis.info('Compiling %d shapes ...', masterShapes);\n\n\t\t\t// Initialize the namespace powers\n\t\t\twhile (!this._namespacePow.length || (Math.pow(26, this._namespacePow.length) < masterShapes)) {\n\t\t\t\tthis._namespacePow.unshift(Math.pow(26, this._namespacePow.length));\n\t\t\t\t_.invoke(this._shapes, 'resetNamespace');\n\t\t\t}\n\n\t\t\t// Sort shapes by ID\n\t\t\tthis._shapes\t\t\t= this._shapes.sort(this.config.shape.sort);\n\n\t\t\t// Set the shape namespaces on all master shapes\n\t\t\t_.reject(this._shapes, function(shape) { return !!shape.master; }).map(function(shape, index){\n\t\t\t\tshape.setNamespace(this._indexNamespace(index));\n\t\t\t}, this);\n\n\t\t\tthis._layout(args[0], function(error, files, data) {\n\n\t\t\t\t// Add intermediate SVG files\n\t\t\t\tif (that.config.shape.dest) {\n\t\t\t\t\tfiles.shapes\t= that._getShapeFiles(that.config.shape.dest);\n\t\t\t\t\tthat.verbose('Returning %d intermediate SVG files', files.shapes.length);\n\t\t\t\t}\n\t\t\t\tthat.info('Finished %s sprite compilation', _.keys(data).map(function(mode){\n\t\t\t\t\treturn '«' + mode + '»';\n\t\t\t\t}).join(' + '));\n\n\t\t\t\tthat._logStats(files);\n\n\t\t\t\targs[1](error, files, data);\n\t\t\t\tthat.emit('compiled');\n\t\t\t});\n\t\t}\n\t}\n};\n\n/**\n * Return a unique namespace prefix for a shape index\n *\n * @param {Number} index\t\tShape index\n * @return {String}\t\t\t\tNamespace prefix\n */\nSVGSpriter.prototype._indexNamespace = function(index) {\n\tfor (var ns = '', n = 0, c; n < this._namespacePow.length; ++n) {\n\t\tc\t\t\t\t\t\t= Math.floor(index / this._namespacePow[n]);\n\t\tns\t\t\t\t\t\t+= String.fromCharCode(97 + c);\n\t\tindex\t\t\t\t\t-= c * this._namespacePow[n];\n\t}\n\treturn ns;\n};\n\n/**\n * Layout the sprites\n *\n * @param {Object} config\t\tLayout configuration\n * @param {Function} cb\t\t\tCallback\n */\nSVGSpriter.prototype._layout = function(config, cb) {\n\tvar tasks\t\t\t\t\t= [],\n\tfiles\t\t\t\t\t\t= {},\n\tlayout\t\t\t\t\t\t= new LAYOUTER(this, config),\n\tcreateLayoutTask\t\t\t= function(k, m){\n\t\treturn function(_cb){\n\t\t\tlayout.layout(files, k, m, _cb);\n\t\t};\n\t};\n\n\tfor (var mode in config) {\n\t\ttasks.push(createLayoutTask(mode, config[mode].mode));\n\t}\n\n\tasync.parallelLimit(tasks, os.cpus().length * 2, function(error, data){\n\t\tcb(error, files, _.zipObject(pluck(data, 'key'), data));\n\t});\n};\n\n/**\n * Return all current shapes\n *\n * @param {String} dest\t\t\tDestination directory\n * @param {Function} cb\t\t\tCallback\n */\nSVGSpriter.prototype.getShapes = function(dest, cb) {\n\tthis._shapesDest.push([dest, cb]);\n\tthis._getShapes();\n};\n\n/**\n * Return all current shapes\n */\nSVGSpriter.prototype._getShapes = function() {\n\n\t// If the shape queue is not currently active\n\tif (!this._queue.active) {\n\t\twhile(this._shapesDest.length) {\n\t\t\tvar args = this._shapesDest.shift();\n\t\t\targs[1](null, this._getShapeFiles(args[0]));\n\t\t}\n\t}\n};\n\n/**\n * Return the shapes as a list of vinyl files\n *\n * @param {String} dest\t\t\tDestination directory\n * @return {Array}\t\t\t\tShape file list\n */\nSVGSpriter.prototype._getShapeFiles = function(dest) {\n\treturn this._shapes.map(function(shape) {\n\t\treturn new File({\n\t\t\tbase\t\t\t\t: this.config.dest,\n\t\t\tpath\t\t\t\t: path.join(dest, shape.id + '.svg'),\n\t\t\tcontents\t\t\t: new Buffer(shape.getSVG(false))\n\t\t});\n\t}, this);\n};\n\n/**\n * Log file statistics\n *\n * @param {Object} files\t\tFiles\n */\nSVGSpriter.prototype._logStats = function(files) {\n\tvar sizes\t\t\t\t\t= {},\n\texts\t\t\t\t\t\t= {};\n\tfor (var mode in files) {\n\t\tfor (var resource in files[mode]) {\n\t\t\tvar file\t\t\t= files[mode][resource].relative,\n\t\t\text\t\t\t\t\t= path.extname(files[mode][resource].path).toUpperCase();\n\t\t\texts[ext]\t\t\t= (exts[ext] || 0) + 1;\n\t\t\tsizes[file]\t\t\t= pretty(files[mode][resource].contents.length);\n\t\t}\n\t}\n\tthis.info('Created ' + _.toPairs(exts).map(function(ext){\n\t\treturn ext[1] + ' x ' + ext[0].substr(1);\n\t}).join(', '));\n\n\tObject.keys(sizes).sort().forEach(function(file){\n\t\tthis.verbose('Created %s: %s', file, sizes[file]);\n\t}, this);\n};\n\n/**\n * Pass info messages on to the logger\n */\nSVGSpriter.prototype.info = function() {\n\tthis.config.log.info.apply(this.config.log, arguments);\n};\n\n/**\n * Pass verbose messages on to the logger\n */\nSVGSpriter.prototype.verbose = function() {\n\tthis.config.log.verbose.apply(this.config.log, arguments);\n};\n\n/**\n * Pass debug messages on to the logger\n */\nSVGSpriter.prototype.debug = function() {\n\tthis.config.log.debug.apply(this.config.log, arguments);\n};\n\n/**\n * Pass error messages on to the logger\n */\nSVGSpriter.prototype.error = function() {\n\tthis.config.log.error.apply(this.config.log, arguments);\n};\n\n/**\n * Module export (constructor wrapper)\n *\n * @param {Object} config\t\tConfiguration\n * @return {SVGSpriter}\t\t\tSVGSpriter instance\n */\nmodule.exports = function(config) {\n\treturn new SVGSpriter(config || {});\n};\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/config.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _\t\t\t\t\t\t\t\t\t= require('lodash'),\n\tpath\t\t\t\t\t\t\t\t= require('path'),\n\tyaml\t\t\t\t\t\t\t\t= require('js-yaml'),\n\tfs\t\t\t\t\t\t\t\t\t= require('fs'),\n\twinston\t\t\t\t\t\t\t\t= require('winston'),\n\t/**\n\t * Sprite types\n\t *\n\t * @type {Array}\n\t */\n\tspriteTypes\t\t\t\t\t\t\t= ['css', 'view', 'defs', 'symbol', 'stack'],\n\t/**\n\t * List of default shape transformations\n\t *\n\t * @type {Array}\n\t */\n\tdefaultShapeTransform\t\t\t\t= ['svgo'],\n\t/**\n\t * Default SVG configuration\n\t *\n\t * @type {Object}\n\t */\n\tdefaultSVGConfig\t\t\t\t\t= {\n\t\t/**\n\t\t * Add a DOCTYPE declaration to SVG documents\n\t\t *\n\t\t * @type {Boolean\n\t\t */\n\t\tdoctypeDeclaration\t\t\t\t: true,\n\t\t/**\n\t\t * Add an XML declaration to SVG documents\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\txmlDeclaration\t\t\t\t\t: true,\n\t\t/**\n\t\t * Namespace IDs in SVG documents to avoid ID clashes\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tnamespaceIDs\t\t\t\t\t: true,\n\t\t/**\n\t\t * Namespace CSS class names in SVG documents to avoid CSS clashes\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tnamespaceClassnames\t      \t\t: true,\n\t\t/**\n\t\t * Add width and height attributes to the sprite SVG\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tdimensionAttributes\t\t\t\t: true,\n\t\t/**\n\t\t * Additional root attributes for the outermost <svg> element\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\trootAttributes\t\t\t\t    : {},\n\t\t/**\n\t\t * Floating point precision for CSS positioning values\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tprecision                       : -1\n\t};\n\n/**\n * SVGSpriter configuration\n *\n * @param {Object} config\t\t\t\tConfiguration\n */\nfunction SVGSpriterConfig(config) {\n\n\t// Logging\n\tthis.log\t\t\t\t\t\t\t= '';\n\tif ('log' in config){\n\t\tif ((config.log instanceof winston.Logger) || (_.isObject(config.log) && !_.isUndefined(config.log.level) && _.isObject(config.log.transports) && _.isFunction(config.log.log))) {\n\t\t\tthis.log\t\t\t\t\t= config.log;\n\t\t} else {\n\t\t\tthis.log\t\t\t\t\t= (_.isString(config.log) && (['info', 'verbose', 'debug'].indexOf(config.log) >= 0)) ? config.log : (config.log ? 'info' : '');\n\t\t}\n\t}\n\tif (_.isString(this.log)) {\n\t\tvar twoDigits\t\t\t\t\t= function(i) {\n\t\t\treturn ('0' + i).slice(-2);\n\t\t};\n\t\tthis.log\t\t\t\t\t\t= new winston.Logger({\n\t\t\ttransports\t\t\t\t\t: [new (winston.transports.Console)({\n\t\t\t\tlevel\t\t\t\t\t: this.log || 'info',\n\t\t\t\tsilent\t\t\t\t\t: !this.log.length,\n\t\t\t\tcolorize\t\t\t\t: true,\n\t\t\t\tprettyPrint\t\t\t\t: true,\n\t\t\t\ttimestamp\t\t\t\t: function() {\n\t\t\t\t\tvar now\t\t\t\t= new Date();\n\t\t\t\t\treturn now.getFullYear() + '-' + twoDigits(now.getMonth()) + '-' + twoDigits(now.getDate()) + ' ' + twoDigits(now.getHours()) + ':' + twoDigits(now.getMinutes()) + ':' + twoDigits(now.getSeconds());\n\t\t\t\t}\n\t\t\t})]\n\t\t});\n\t}\n\n\tthis.log.debug('Started logging');\n\n\tthis.dest\t\t\t\t\t\t\t= path.resolve(config.dest || '.');\n\n\tthis.log.debug('Prepared general options');\n\n\tthis.shape\t\t\t\t\t\t\t= ('shape' in config) ? _.assign({}, config.shape || {}) : {};\n\n\tvar stat, t, transforms = null;\n\n\t// Parse meta data (if configured)\n\tif (('meta' in this.shape) && !_.isPlainObject(this.shape.meta)) {\n\t\tvar meta\t\t\t\t\t\t= _.isString(this.shape.meta) ? path.resolve(this.shape.meta) : null,\n\t\tmetaFile\t\t\t\t\t\t= meta;\n\t\tstat\t\t\t\t\t\t\t= meta ? fs.lstatSync(meta) : null;\n\t\tthis.shape.meta\t\t\t\t\t= {};\n\t\tif (stat) {\n\t\t\tif (stat.isSymbolicLink()) {\n\t\t\t\tmeta\t\t\t\t\t= fs.readlinkSync(meta);\n\t\t\t\tstat\t\t\t\t\t= fs.statSync(meta);\n\t\t\t}\n\t\t\tmeta\t\t\t\t\t\t= stat.isFile() ? fs.readFileSync(meta, 'utf8') : null;\n\t\t\tmeta\t\t\t\t\t\t= meta ? yaml.safeLoad(meta) : {};\n\t\t\tfor (var m in meta) {\n\t\t\t\tif (_.isPlainObject(meta[m])) {\n\t\t\t\t\tthis.shape.meta[path.join(path.dirname(m), path.basename(m, '.svg'))] = _.pick(meta[m], ['title', 'description']);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.log.debug('Processed meta data file \"%s\"', path.basename(metaFile));\n\t\t}\n\t} else {\n\t\tthis.shape.meta\t\t\t\t\t= {};\n\t}\n\n\t// Parse alignment data (if configured)\n\tif (('align' in this.shape) && !_.isPlainObject(this.shape.align)) {\n\t\tvar align\t\t\t\t\t\t= _.isString(this.shape.align) ? path.resolve(this.shape.align) : null,\n\t\talignFile\t\t\t\t\t\t= align;\n\t\tstat\t\t\t\t\t\t\t= align ? fs.lstatSync(align) : null;\n\t\tthis.shape.align\t\t\t\t= {'*': {'%s': 0}};\n\t\tif (stat) {\n\t\t\tif (stat.isSymbolicLink()) {\n\t\t\t\talign\t\t\t\t\t= fs.readlinkSync(align);\n\t\t\t\tstat\t\t\t\t\t= fs.statSync(align);\n\t\t\t}\n\t\t\talign\t\t\t\t\t\t= stat.isFile() ? fs.readFileSync(align, 'utf8') : null;\n\t\t\talign\t\t\t\t\t\t= align ? yaml.safeLoad(align) : {};\n\t\t\tfor (var a in align) {\n\t\t\t\tif (_.isPlainObject(align[a]) && Object.keys(align[a]).length) {\n\t\t\t\t\tthis.shape.align[a]\t= this.shape.align[a] || {};\n\t\t\t\t\tfor (var tmpl in align[a]) {\n\t\t\t\t\t\tvar template\t= tmpl.length ? ((tmpl.indexOf('%s') >= 0) ? tmpl : ('%s' + tmpl)) : '%s';\n\t\t\t\t\t\tthis.shape.align[path.join(path.dirname(a), path.basename(a, '.svg'))][template] = Math.max(0, Math.min(1, parseFloat(align[a][tmpl], 10)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.log.debug('Processed alignment data file \"%s\"', path.basename(alignFile));\n\t\t}\n\t} else {\n\t\tthis.shape.align\t\t\t\t= {'*': {'%s': 0}};\n\t}\n\n\t// Register a sorting callback for shape names\n\tif (!('sort' in this.shape) || !_.isFunction(this.shape.sort)) {\n\t\tthis.shape.sort\t\t\t\t\t= function(shape1, shape2){\n\t\t\treturn (shape1.id === shape2.id) ? 0 : ((shape1.id > shape2.id) ? 1 : -1);\n\t\t};\n\t}\n\n\t// Intermediate SVG destination\n\tthis.shape.dest\t\t\t\t\t\t= ('dest' in this.shape) ? ('' + this.shape.dest).trim() : '';\n\tthis.shape.dest\t\t\t\t\t\t= this.shape.dest.length ? path.resolve(this.dest, this.shape.dest) : null;\n\n\t// Expand spacing options to arrays\n\tthis.shape.spacing\t\t\t\t\t= ('spacing' in this.shape) ? (this.shape.spacing || {}) : {};\n\t['padding'].forEach(function(property){\n\t\tvar spacing;\n\n\t\tif (!_.isArray(this.spacing[property])) {\n\t\t\tspacing\t\t\t\t\t\t= Math.max(0, parseInt(this.spacing[property] || 0, 10));\n\t\t\tthis.spacing[property]\t\t= {top: spacing, right: spacing, bottom: spacing, left: spacing};\n\t\t} else {\n\t\t\tspacing\t\t\t\t\t\t= this.spacing[property].map(function(n){ return Math.max(0, n); });\n\t\t\tswitch(spacing.length) {\n\t\t\t\tcase 1:\n\t\t\t\t\tspacing\t\t\t\t= {top: spacing[0], right: spacing[0], bottom: spacing[0], left: spacing[0]};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tspacing\t\t\t\t= {top: spacing[0], right: spacing[1], bottom: spacing[0], left: spacing[1]};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tspacing\t\t\t\t= {top: spacing[0], right: spacing[1], bottom: spacing[2], left: spacing[1]};\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tspacing\t\t\t\t= {top: spacing[0], right: spacing[1], bottom: spacing[2], left: spacing[3]};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.spacing[property]\t\t= spacing;\n\t\t}\n\t}, this.shape);\n\n\t// Prepare shape transforms\n\tif (('transform' in this.shape) && _.isArray(this.shape.transform)) {\n\t\ttransforms\t\t\t\t\t\t= this.shape.transform;\n\t}\n\n\t// Alternatively use deprecated top-level transforms\n\t// TODO: Remove in future version\n\tif ('transform' in config) {\n\t\tthis.log.warn('The top-level `transform` option is deprecated and will be removed in a future version. Please use `shape.transform` instead.');\n\n\t\tif ((transforms === null) && _.isArray(config.transform)) {\n\t\t\ttransforms\t\t\t\t\t= config.transform;\n\t\t}\n\t}\n\n\t// Fallback: Use default transformations\n\tif (transforms === null) {\n\t\ttransforms\t\t\t\t\t\t= defaultShapeTransform;\n\t}\n\n\tthis.shape.transform\t\t\t\t= [];\n\tif (_.isArray(transforms)) {\n\t\ttransformers: for (t = 0; t < transforms.length; ++t) {\n\t\t\tif (_.isString(transforms[t])) {\n\t\t\t\ttransforms[t]\t\t\t= JSON.parse('{\"' + transforms[t] + '\":true}');\n\t\t\t} else if (_.isFunction(transforms[t])) {\n\t\t\t\tvar custom\t\t\t\t= {};\n\t\t\t\tcustom.custom\t\t\t= transforms[t];\n\t\t\t\ttransforms[t]\t\t\t= custom;\n\t\t\t}\n\t\t\tif (_.isObject(transforms[t])) {\n\t\t\t\tfor (var transformer in transforms[t]) {\n\t\t\t\t\tvar tconfig\t\t\t= transforms[t][transformer];\n\t\t\t\t\tif ((tconfig === true) || _.isObject(tconfig) || _.isFunction(tconfig)) {\n\t\t\t\t\t\tthis.shape.transform.push([transformer, (tconfig === true) ? {} : tconfig]);\n\t\t\t\t\t\tcontinue transformers;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.log.debug('Prepared `shape` options');\n\n\tthis.svg\t\t\t\t\t\t\t= _.clone(defaultSVGConfig);\n\tthis.svg\t\t\t\t\t\t\t= ('svg' in config) ? _.assign(this.svg, config.svg || {}) : this.svg;\n\tthis.svg.xmlDeclaration\t\t\t\t= this.svg.xmlDeclaration || false;\n\tthis.svg.doctypeDeclaration\t\t\t= this.svg.doctypeDeclaration || false;\n\tthis.svg.dimensionAttributes\t\t= this.svg.dimensionAttributes || false;\n\tthis.svg.rootAttributes\t\t        = this.svg.rootAttributes || {};\n\tthis.svg.precision                  = Math.max(-1, parseInt(this.svg.precision || -1));\n\n\t// Prepare post-processing transforms\n\ttransforms\t\t\t\t\t\t\t= [];\n\tif ('transform' in this.svg) {\n\t\tif (_.isFunction(this.svg.transform)) {\n\t\t\ttransforms.push(this.svg.transform);\n\t\t} else if (_.isArray(this.svg.transform)) {\n\t\t\tfor (t = 0; t < this.svg.transform.length; ++t) {\n\t\t\t\tif (_.isFunction(this.svg.transform[t])) {\n\t\t\t\t\ttransforms.push(this.svg.transform[t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tthis.svg.transform\t\t\t\t\t= transforms;\n\n\tthis.log.debug('Prepared `svg` options');\n\n\tthis.mode\t\t\t\t\t\t\t= this.filter(config.mode);\n\n\tthis.log.debug('Prepared `mode` options');\n\n\tthis.variables\t\t\t\t\t\t= _.extend({}, config.variables);\n\n\tthis.log.debug('Prepared `variables` options');\n\n\tthis.log.verbose('Initialized spriter configuration');\n}\n\n/**\n * Pick out the relevant mode options out of a configuration object\n *\n * @param {Object} config\t\t\t\tConfiguration object\n * @return {Object}\t\t\t\t\t\tMode relevant options\n */\nSVGSpriterConfig.prototype.filter = function(config) {\n\tvar filtered\t\t\t\t\t\t= {};\n\tconfig\t\t\t\t\t\t\t\t= config || {};\n\tfor (var m in config) {\n\t\tvar modeConfig\t\t\t\t\t= _.isPlainObject(config[m]) ? config[m] : ((config[m] === true) ? {} : null);\n\t\tif ((modeConfig !== null) && (spriteTypes.indexOf(modeConfig.mode || m) >= 0)) {\n\t\t\tfiltered[m]\t\t\t\t\t= modeConfig;\n\t\t\tfiltered[m].mode\t\t\t= modeConfig.mode || m;\n\t\t}\n\t}\n\treturn filtered;\n};\n\n/**\n * Module export (constructor wrapper)\n *\n * @param {Object} config\t\t\t\tConfiguration\n * @return {SVGSpriterConfig}\t\t\tSVGSpriter configuration\n */\nmodule.exports = function(config) {\n\treturn new SVGSpriterConfig(config || {});\n};\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/queue.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar path\t\t\t\t= require('path'),\nasync\t\t\t\t\t= require('async'),\nos\t\t\t\t\t\t= require('os'),\nevents\t\t\t\t\t= require('events'),\nSHAPE\t\t\t\t\t= require('./shape');\n\n/**\n * SVGSpriter queue\n *\n * @param {SVGSpriter} spriter\t\t\tSVGSpriter instance\n */\nfunction SVGSpriterQueue(spriter) {\n\tthis._spriter\t\t= spriter;\n\tthis._files\t\t\t= [];\n\tthis._limit\t\t\t= os.cpus().length * 2;\n\tthis.active\t\t\t= 0;\n\n\tevents.EventEmitter.call(this);\n\tthis.on('add', this.process.bind(this));\n\tthis.on('remove', this.process.bind(this));\n\n\tthis._spriter.debug('Created processing queue instance');\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriterQueue.prototype = Object.create(events.EventEmitter.prototype);\n\n/**\n * Add a shape to the processing queue\n *\n * @param {File} file\t\t\t\t\tShape file\n */\nSVGSpriterQueue.prototype.add = function(file) {\n\tthis._spriter.debug('Added \"%s\" to processing queue', file.path.substr(file.base.length + path.sep.length));\n\tthis._files.push(file);\n\tthis.emit('add');\n};\n\n/**\n * Try to process an item in the queue\n */\nSVGSpriterQueue.prototype.process = function() {\n\tif (this._files.length && (this.active < this._limit)) {\n\t\t++this.active;\n\t\tvar file\t\t= this._files.shift();\n\n\t\t// Instanciate the shape\n\t\ttry {\n\t\t\tvar shape\t= new SHAPE(file, this._spriter),\n\t\t\tspriter\t\t= this._spriter;\n\n\t\t// In case of errors: Skip the file\n\t\t} catch(e) {\n\t\t\tthis._spriter.error('Skipping \"%s\" (%s)', file.path.substr(file.base.length + path.sep.length), e.message);\n\t\t\tthis.emit(--this.active ? 'remove' : 'empty');\n\t\t\treturn;\n\t\t}\n\n\t\t// Subsequently run through all optimization and compilation tasks\n\t\tasync.waterfall([\n\n\t\t\t// Transform the shape\n\t\t\tfunction(_cb){\n\t\t\t\tspriter._transformShape(shape, _cb);\n\t\t\t},\n\n\t\t\t// Complement the shape\n\t\t\tfunction(_cb){\n\t\t\t\tshape.complement(_cb);\n\t\t\t}\n\n\t\t], this.remove.bind(this));\n\t}\n};\n\n/**\n * Remove a shape from the queue\n *\n * @param {Error} error\t\t\t\t\tError\n * @param {SVGShape} shape\t\t\t\tProcessed shape\n */\nSVGSpriterQueue.prototype.remove = function(error, shape) {\n\tArray.prototype.push.apply(this._spriter._shapes, shape.distribute());\n\tthis.emit(--this.active ? 'remove' : 'empty');\n};\n\n/**\n * Module export (constructor wrapper)\n *\n * @param {SVGSpriter} spriter\t\t\tSVGSpriter instance\n * @return {SVGSpriterQueue}\t\t\tSVGSpriterQueue instance\n */\nmodule.exports = SVGSpriterQueue;\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/shape.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _\t\t\t\t\t\t= require('lodash'),\npath\t\t\t\t\t\t= require('path'),\nutil\t\t\t\t\t\t= require('util'),\nxmldom\t\t\t\t\t\t= require('xmldom'),\nDOMParser\t\t\t\t\t= xmldom.DOMParser,\nXMLSerializer\t\t\t\t= xmldom.XMLSerializer,\nxpath\t\t\t\t\t\t= require('xpath'),\ncssom\t\t\t\t\t\t= require('cssom'),\nCssSelectorParser\t\t\t= require('css-selector-parser').CssSelectorParser,\ncsssel\t\t\t\t\t\t= new CssSelectorParser(),\nexecFile\t\t\t\t\t= require('child_process').execFile,\nphantomjs\t\t\t\t\t= require('phantomjs-prebuilt').path,\ndimensionsPhantomScript\t\t= path.resolve(__dirname, 'shape/dimensions.phantom.js'),\nasync\t\t\t\t\t\t= require('async'),\n/**\n * Default callback for shape ID generation\n *\n * @param {String} template\t\t\tTemplate string\n * @return {String}\t\t\t\t\tShape ID\n */\ncreateIdGenerator\t\t\t= function(template) {\n\t/**\n\t * ID generator\n\t *\n\t * @param {String} name\t\t\tRelative file path\n\t * @param {File} file\t\t\tOriginal vinyl file\n\t * @returns {String}\t\t\tShape ID\n     */\n\tvar generator = function(name, file) {\n\t\treturn util.format(template || '%s', path.basename(name.split(path.sep).join(this.separator).replace(/\\s+/g, this.whitespace), '.svg'));\n\t};\n\treturn generator;\n},\n/**\n * Default shape configuration\n *\n * @type {Object}\n */\ndefaultConfig\t\t\t\t= {\n\t/**\n\t * Shape ID related options\n\t *\n\t * @type {Object}\n\t */\n\tid\t\t\t\t\t\t: {\n\t\t/**\n\t\t * ID part separator (used for directory-to-ID traversal)\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tseparator\t\t\t: '--',\n\t\t/**\n\t\t * Pseudo selector separator\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tpseudo\t\t\t\t: '~',\n\t\t/**\n\t\t * Whitespace replacement string\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\twhitespace\t\t\t: '_',\n\t\t/**\n\t\t * ID traversal callback\n\t\t *\n\t\t * @param {Function}\n\t\t */\n\t\tgenerator\t\t\t: createIdGenerator('%s')\n\t},\n\t/**\n\t * Dimension related options\n\t *\n\t * @type {Object}\n\t */\n\tdimension\t\t\t\t: {\n\t\t/**\n\t\t * Max. shape width\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tmaxWidth\t\t\t: 2000,\n\t\t/**\n\t\t * Max. shape height\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tmaxHeight\t\t\t: 2000,\n\t\t/**\n\t\t * Coordinate decimal places\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tprecision\t\t\t: 2,\n\t\t/**\n\t\t * Add dimension attributes\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tattributes\t\t\t: false\n\t},\n\t/**\n\t * Spacing related options\n\t *\n\t * @type {Number}\n\t */\n\tspacing\t\t\t\t\t: {\n\t\t/**\n\t\t * Padding around the shape\n\t\t *\n\t\t * @type {Number|Array}\n\t\t */\n\t\tpadding\t\t\t\t: {top: 0, right: 0, bottom: 0, left: 0},\n\t\t/**\n\t\t * Box sizing strategy\n\t\t *\n\t\t * Might be 'content' (padding is added outside of the shape), 'padding' (shape plus padding will make for the given maximum size)\n\t\t * or 'contain' (like 'padding', but size will be fixed instead of maximum)\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tbox\t\t\t\t\t: 'content'\n\t}\n},\nsvgReferenceProperties\t\t= ['style', 'fill', 'stroke', 'filter', 'clip-path', 'mask',  'marker-start', 'marker-end', 'marker-mid'];\n\n/**\n * SVGShape\n *\n * @param {File} file\t\t\t\t\tVinyl file\n * @param {SVGSpriter} spriter\t\t\tSpriter instance\n */\nfunction SVGShape(file, spriter) {\n\tthis.source\t\t\t\t= file;\n\tthis.spriter\t\t\t= spriter;\n\tthis.svg\t\t\t\t= {current: this.source.contents.toString(), ready: null};\n\tthis.name\t\t\t\t= this.source.path.substr(this.source.base.length + path.sep.length);\n\tthis.config\t\t\t\t= _.merge(_.clone(defaultConfig, true), this.spriter.config.shape || {});\n\n\tif (!_.isFunction(this.config.id.generator)) {\n\t\tthis.config.id.generator\t\t= createIdGenerator(_.isString(this.config.id.generator) ? (this.config.id.generator + ((this.config.id.generator.indexOf('%s') >= 0) ? '' : '%s')) : '%s');\n\t}\n\n\tthis.id\t\t\t\t\t= this.config.id.generator(this.name, this.source);\n\tthis.state\t\t\t\t= this.id.split(this.config.id.pseudo);\n\tthis.base\t\t\t\t= this.state.shift();\n\tthis.state\t\t\t\t= this.state.shift() || null;\n\tthis.master\t\t\t\t= null;\n\tthis.copies\t\t\t\t= 0;\n\tthis._precision\t\t\t= Math.pow(10, +this.config.dimension.precision);\n\tthis._scale\t\t\t\t= 1;\n\tthis._namespaced\t\t= false;\n\n\t// Determine meta & alignment data\n\tvar relative\t\t\t= path.basename(this.source.relative, '.svg');\n\tthis.meta\t\t\t\t= (this.id in this.config.meta) ? this.config.meta[this.id] : ((relative in this.config.meta) ? this.config.meta[relative] : {});\n\tthis.align\t\t\t\t= _.toPairs(_.extend({}, this.config.align['*'], (this.id in this.config.align) ? this.config.align[this.id] : ((relative in this.config.align) ? this.config.align[relative] : {})));\n\n\t// Initially set the SVG of this shape\n\tthis._initSVG();\n\n\t// XML declaration and doctype\n\tvar xmldecl\t\t\t\t= this.svg.current.match(/<\\?xml.*?>/gi),\n\tdoctype\t\t\t\t\t= this.svg.current.match(/<!DOCTYPE.*?>/gi);\n\tthis.xmlDeclaration\t\t= xmldecl ? xmldecl[0] : '<?xml version=\"1.0\" encoding=\"utf-8\"?>';\n\tthis.doctypeDeclaration\t= doctype ? doctype[0] : '';\n\n\tthis.spriter.verbose('Added shape \"%s:%s\"', this.base, this.state || 'regular');\n}\n\n/**\n * Prototype properties\n *\n * @type {Object}\n */\nSVGShape.prototype = {};\n\n/**\n * SVG stages\n *\n * @type {Object}\n */\nSVGShape.prototype.svg\t\t= null;\n\n/**\n * Default SVG namespace\n *\n * @type {String}\n */\nSVGShape.prototype.DEFAULT_SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\n/**\n * Xlink namespace\n *\n * @type {String}\n */\nSVGShape.prototype.XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';\n\n/**\n * Return a string representation of the shape\n *\n * @return {String}\t\t\tString representation\n */\nSVGShape.prototype.toString = function() {\n\treturn '[object SVGShape]';\n};\n\n/**\n * Recursively strip unneeded namespace declarations\n *\n * @param {Element} element \tElement\n * @param {Object} nsMap\t\tNamespace map\n * @return {Element}\t\t\tElement\n */\nSVGShape.prototype._stripInlineNamespaceDeclarations = function(element, nsMap) {\n\tvar parentNsMap\t\t\t\t= _.clone(element._nsMap);\n\tnsMap\t\t\t\t\t\t= nsMap || {'': this.DEFAULT_SVG_NAMESPACE};\n\n\t// Strip the default SVG namespace\n\tif (nsMap[''] === this.DEFAULT_SVG_NAMESPACE) {\n\t\tvar defaultNamespace\t= element.attributes.getNamedItem('xmlns');\n\t\tif (!_.isUndefined(defaultNamespace) && (defaultNamespace.value === this.DEFAULT_SVG_NAMESPACE)) {\n\t\t\telement.attributes.removeNamedItem('xmlns');\n\t\t}\n\t}\n\n\tif (!('xlink' in nsMap) || (nsMap.xlink === this.XLINK_NAMESPACE)) {\n\t\tvar xlinkNamespace\t\t= element.attributes.getNamedItem('xmlns:xlink');\n\t\tif (!_.isUndefined(xlinkNamespace) && (xlinkNamespace.value === this.XLINK_NAMESPACE)) {\n\t\t\telement.attributes.removeNamedItem('xmlns:xlink');\n\t\t}\n\t}\n\n\tfor (var c = 0; c < element.childNodes.length; ++c) {\n\t\tif (element.childNodes.item(c).nodeType === 1) {\n\t\t\tthis._stripInlineNamespaceDeclarations(element.childNodes.item(c), parentNsMap);\n\t\t}\n\t}\n\n\treturn element;\n};\n\n/**\n * Return the SVG of this shape\n *\n * @param {Boolean}\tinline\t\t\tPrepare for inline usage (strip redundant XML namespaces)\n * @param {Function} transform\t\tFinal transformer before serialization (operating on a clone)\n * @return {String}\t\t\t\t\tSVG\n */\nSVGShape.prototype.getSVG = function(inline, transform) {\n\tvar svg;\n\n\t// If this is a distributed copy\n\tif (this.master) {\n\t\tsvg\t\t\t\t\t= this.dom.createElementNS(this.DEFAULT_SVG_NAMESPACE, 'use');\n\t\tsvg.setAttribute('xlink:href', '#' + this.master.id);\n\n\t// Else\n\t} else {\n\t\tsvg\t\t\t\t\t= this.dom.documentElement.cloneNode(true);\n\t}\n\n\t// Call the final transformer (if available)\n\tif (_.isFunction(transform)) {\n\t\ttransform(svg);\n\t}\n\n\t// If the SVG is to be used inline or as part of a sprite or is a distributed copy: Strip redundand namespace declarations\n\tif (inline || this.master) {\n\t\treturn new XMLSerializer().serializeToString(this._stripInlineNamespaceDeclarations(svg));\n\n\t// Else: Add XML and DOCTYPE declarations if required\n\t} else {\n\t\tsvg\t\t\t\t\t= new XMLSerializer().serializeToString(svg);\n\n\t\t// Add DOCTYPE declaration\n\t\tif (this.spriter.config.svg.doctypeDeclaration) {\n\t\t\tsvg\t\t\t\t= this.doctypeDeclaration + svg;\n\t\t}\n\n\t\t// Add XML declaration\n\t\tif (this.spriter.config.svg.xmlDeclaration) {\n\t\t\tsvg\t\t\t\t= this.xmlDeclaration + svg;\n\t\t}\n\t}\n\n\treturn svg;\n};\n\n/**\n * Set the SVG of this shape\n *\n * @param {String} svg\t\tSVG\n * @return {SVGShape}\t\tSelf reference\n */\nSVGShape.prototype.setSVG = function(svg) {\n\tthis.svg.current\t\t= svg;\n\tthis.svg.ready\t\t\t= null;\n\treturn this._initSVG();\n};\n\n/**\n * Initialize the SVG of this shape\n *\n * @return {SVGShape}\t\tSelf reference\n */\nSVGShape.prototype._initSVG = function() {\n\n\t// Basic check for basic SVG file structure\n\tvar svgStart\t\t\t= this.svg.current.match(/<svg(?:\\s+[a-z0-9-\\:]+=(\"|').*?\\1)*\\s*(?:(\\/)|(>[^]*<\\/svg))>/i);\n\tif (!svgStart) {\n\t\tvar e\t\t\t\t= new Error('Invalid SVG file');\n\t\te.name\t\t\t\t= 'ArgumentError';\n\t\te.errno\t\t\t\t= 1429395394;\n\t\tthrow e;\n\t}\n\n\t// Resolve XML entities\n\tvar entityRegExp\t\t= /<!ENTITY\\s+([^\\s]+)\\s+(\"|')(.+)(?:\\2)>/i;\n\tvar entityStart\t\t\t= 0;\n\tvar entities\t\t\t= 0;\n\tvar entityMap\t\t\t= {};\n\tvar entity;\n\tdo {\n\t\tentity\t\t\t\t= entityRegExp.exec(this.svg.current.substr(entityStart));\n\t\tif (entity) {\n\t\t\t++entities;\n\t\t\tentityStart\t\t+= entity.index + entity[0].length;\n\t\t\tentityMap[entity[1]] = entity[3];\n\t\t}\n\t} while(entity);\n\tif (entities) {\n\t\tvar svg\t\t\t\t= this.svg.current.substr(svgStart.index);\n\t\tfor (entity in entityMap) {\n\t\t\tsvg\t\t\t\t= svg.replace('&' + entity + ';', entityMap[entity]);\n\t\t}\n\t\tthis.svg.current\t= this.svg.current.substr(0, svgStart.index) + svg;\n\t}\n\n\t// Parse the XML\n\tthis.dom\t\t\t\t= new DOMParser({\n\t\tlocator\t\t\t\t: {},\n\t\terrorHandler\t\t: function(level, message) {\n\t\t\tvar e\t\t\t= new Error(util.format('Invalid SVG file (%s)', message.split('\\n').join(' ')));\n\t\t\te.name\t\t\t= 'ArgumentError';\n\t\t\te.errno\t\t\t= 1429394706;\n\t\t\tthrow e;\n\t\t}\n\t}).parseFromString(this.svg.current);\n\n\t// Determine the shape width\n\tvar width\t\t\t\t= this.dom.documentElement.getAttribute('width');\n\tthis.width\t\t\t\t= width.length ? parseFloat(width, 10) : false;\n\n\t// Determine the shape height\n\tvar height\t\t\t\t= this.dom.documentElement.getAttribute('height');\n\tthis.height\t\t\t\t= height.length ? parseFloat(height, 10) : false;\n\n\t// Determine the viewbox\n\tvar viewBox\t\t\t\t= this.dom.documentElement.getAttribute('viewBox');\n\tif (viewBox.length) {\n\t\tviewBox\t\t\t\t= viewBox.split(/[^-\\d\\.]+/);\n\t\twhile (viewBox.length < 4) {\n\t\t\tviewBox.push(0);\n\t\t}\n\t\tviewBox.forEach(function(value, index) {\n\t\t\tviewBox[index]\t= parseFloat(value, 10);\n\t\t});\n\t\tthis.viewBox\t\t= viewBox;\n\t} else {\n\t\tthis.viewBox\t\t= false;\n\t}\n\n\tthis.title\t\t\t\t=\n\tthis.description\t\t= null;\n\tfor (var c = 0, children = this.dom.documentElement.childNodes, cl = children.length, meta = {title: 'title', description: 'desc'}; c < cl; ++c) {\n\t\tfor (var m in meta) {\n\t\t\tif (meta[m] === children.item(c).localName) {\n\t\t\t\tthis[m]\t\t= children.item(c);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this;\n};\n\n/**\n * Return the dimensions of this shape\n *\n * @return {Object}\t\t\t\tDimensions\n */\nSVGShape.prototype.getDimensions = function() {\n\treturn {width: this.width, height: this.height};\n};\n\n/**\n * Set the dimensions of this shape\n *\n * @param {Number} width\t\tWidth\n * @param {Number} height\t\tHeight\n * @return {SVGShape}\t\t\tSelf reference\n */\nSVGShape.prototype.setDimensions = function(width, height) {\n\tthis.width\t\t\t\t= this._round(Math.max(0, parseFloat(width, 10)));\n\tthis.dom.documentElement.setAttribute('width', this.width);\n\tthis.height\t\t\t\t= this._round(Math.max(0, parseFloat(height, 10)));\n\tthis.dom.documentElement.setAttribute('height', this.height);\n\treturn this;\n};\n\n/**\n * Return the shape's viewBox (and set it if it doesn't exist yet)\n *\n * @param {Number} width\t\tWidth\n * @param {Height} height\t\tHeight\n * @return {Array}\t\t\t\tViewbox\n */\nSVGShape.prototype.getViewbox = function(width, height) {\n\tif (!this.viewBox) {\n\t\tthis.setViewbox(0, 0, width || this.width, height || this.height);\n\t}\n\treturn this.viewBox;\n};\n\n/**\n * Set the shape's viewBox\n *\n * @param {Number} x\t\t\tX coordinate\n * @param {Number} y\t\t\tY coordinate\n * @param {Number} width\t\tWidth\n * @param {Number} height\t\tHeight\n * @return {Array}\t\t\t\tViewbox\n */\nSVGShape.prototype.setViewbox = function(x, y, width, height) {\n\tif (_.isArray(x)) {\n\t\tthis.viewBox\t\t= x.map(function(n) { return parseFloat(n, 10); });\n\t\twhile (this.viewBox.length < 4) {\n\t\t\tthis.viewBox.push(0);\n\t\t}\n\t} else {\n\t\tthis.viewBox\t\t= [parseFloat(x, 10), parseFloat(y, 10), parseFloat(width, 10), parseFloat(height, 10)];\n\t}\n\tthis.dom.documentElement.setAttribute('viewBox', this.viewBox.join(' '));\n\treturn this.viewBox;\n};\n\n/**\n * Complement the SVG shape by adding dimensions, padding and meta data\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype.complement = function(cb) {\n\tvar that\t\t\t\t= this;\n\tasync.waterfall([\n\n\t\t// Prepare dimensions\n\t\tthis._complementDimensions.bind(this),\n\n\t\t// Set padding\n\t\tthis._addPadding.bind(this),\n\n\t\t// Set meta data\n\t\tthis._addMetadata.bind(this)\n\n\t], function(error) {\n\n\t\t// Save the transformed state\n\t\tthat.svg.ready\t\t= new XMLSerializer().serializeToString(that.dom.documentElement);\n\t\tcb(error, that);\n\t});\n};\n\n/**\n * Complement the shape's dimensions\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype._complementDimensions = function(cb) {\n\tif (this.width && this.height) {\n\t\tthis._setDimensions(cb);\n\t} else {\n\t\tthis._determineDimensions(this._setDimensions.bind(this, cb));\n\t}\n};\n\n/**\n * Determine the shape's dimension by rendering it\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype._determineDimensions = function(cb) {\n\n\t// Try to use a viewBox attribute for image determination\n\tif (this.viewBox !== false) {\n\t\tthis.width\t\t\t\t= this.viewBox[2];\n\t\tthis.height\t\t\t\t= this.viewBox[3];\n\t}\n\n\t// If the viewBox attribute didn't suffice: Render the SVG image\n\tif (!this.width || !this.height) {\n\t\tvar that\t\t\t\t= this;\n\t    execFile(phantomjs, [dimensionsPhantomScript, this.getSVG(false), 'file://' + this.source.path], function (err, stdout, stderr) {\n\t        if (err) {\n\t            cb(err);\n\t        } else if (stdout.length > 0) { // PhantomJS always outputs to stdout.\n\t        \tvar dimensions\t= JSON.parse(stdout.toString().trim());\n\t        \tthat.width\t\t= dimensions.width;\n\t        \tthat.height\t\t= dimensions.height;\n\t        \tcb(null);\n\t        } else if (stderr.length > 0) {\n\t            cb(new Error(stderr.toString().trim()));\n\t        } else {\n\t            cb(new Error('PhantomJS didn\\'t return dimensions for \"' + that.name + '\"'));\n\t        }\n\t    });\n\t} else {\n\t\tcb(null);\n\t}\n};\n\n/**\n * Round a number considering the given decimal place precision\n *\n * @param {Number} n\t\t\tNumber\n * @return {Number}\t\t\t\tRounded number\n */\nSVGShape.prototype._round = function(n) {\n\treturn Math.round(n * this._precision) / this._precision;\n};\n\n/**\n * Scale the shape if necessary\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype._setDimensions = function(cb) {\n\n\t// Ensure the original viewBox is set\n\tthis.getViewbox(this.width, this.height);\n\n\tvar includePadding\t\t= (['padding', 'icon'].indexOf(this.config.spacing.box) >= 0),\n\tforceScale\t\t\t\t= (this.config.spacing.box === 'icon'),\n\thorizontalPadding\t\t= includePadding * Math.max(0, this.config.spacing.padding.right + this.config.spacing.padding.left),\n\twidth\t\t\t\t\t= this.width + horizontalPadding,\n\tverticalPadding\t\t\t= includePadding * Math.max(0, this.config.spacing.padding.top + this.config.spacing.padding.bottom),\n\theight\t\t\t\t\t= this.height + verticalPadding;\n\n\t// Does the shape need to be scaled?\n\tif ((width > this.config.dimension.maxWidth) || (height > this.config.dimension.maxHeight) || (forceScale && (width < this.config.dimension.maxWidth) && (height < this.config.dimension.maxHeight))) {\n\t\tvar maxWidth\t\t= this.config.dimension.maxWidth - horizontalPadding,\n\t\tmaxHeight\t\t\t= this.config.dimension.maxHeight - verticalPadding;\n\t\tthis._scale\t\t\t= Math.min(maxWidth / this.width, maxHeight / this.height);\n\t\tthis.width\t\t\t= Math.min(maxWidth, this._round(this.width * this._scale));\n\t\tthis.height\t\t\t= Math.min(maxHeight, this._round(this.height * this._scale));\n\t}\n\n\t// In \"icon\" box sizing mode: Resize bounding box and center shape by adding padding\n\tif (forceScale) {\n\t\tvar diffWidth\t\t= this.config.dimension.maxWidth - this.width - horizontalPadding,\n\t\tdiffHeight\t\t\t= this.config.dimension.maxHeight - this.height - verticalPadding;\n\t\tthis.config.spacing.padding.left\t\t+= diffWidth / 2;\n\t\tthis.config.spacing.padding.right\t\t+= diffWidth / 2;\n\t\tthis.config.spacing.padding.top\t\t\t+= diffHeight / 2;\n\t\tthis.config.spacing.padding.bottom\t\t+= diffHeight / 2;\n\t}\n\n\tvar dimensions\t\t\t= this.getDimensions();\n\tfor (var attr in dimensions) {\n\t\tthis.dom.documentElement.setAttribute(attr, dimensions[attr]);\n\t}\n\tcb(null);\n};\n\n/**\n * Add padding to this shape\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype._addPadding = function(cb) {\n\tvar padding\t\t\t\t= this.config.spacing.padding;\n\tif (padding.top || padding.right || padding.bottom || padding.left) {\n\n\t\t// Update viewBox\n\t\tvar viewBox\t\t\t= this.getViewbox();\n\t\tviewBox[0]\t\t\t-= this.config.spacing.padding.left / this._scale;\n\t\tviewBox[1]\t\t\t-= this.config.spacing.padding.top / this._scale;\n\t\tviewBox[2]\t\t\t+= (this.config.spacing.padding.right + this.config.spacing.padding.left) / this._scale;\n\t\tviewBox[3]\t\t\t+= (this.config.spacing.padding.top + this.config.spacing.padding.bottom) / this._scale;\n\t\tthis.setViewbox(viewBox.map(this._round.bind(this)));\n\n\t\t// Update dimensions\n\t\tthis.setDimensions(this.width + this.config.spacing.padding.right + this.config.spacing.padding.left, this.height + this.config.spacing.padding.top + this.config.spacing.padding.bottom);\n\t}\n\tcb(null);\n};\n\n/**\n * Add metadata to this shape\n *\n * @param {Function} cb\t\t\tCallback\n */\nSVGShape.prototype._addMetadata = function(cb) {\n\tvar ariaLabelledBy\t\t\t\t\t= [];\n\n\t// Check if description meta data is available\n\tif (('description' in this.meta) && _.isString(this.meta.description) && this.meta.description.length) {\n\t\tif (!this.description) {\n\t\t\tthis.description\t\t\t= this.dom.documentElement.insertBefore(this.dom.createElementNS(this.DEFAULT_SVG_NAMESPACE, 'desc'), this.dom.documentElement.firstChild);\n\t\t}\n\t\tthis.description.textContent\t= this.meta.description;\n\t\tthis.description.setAttribute('id', this.id + '-desc');\n\t\tariaLabelledBy.push(this.id + '-desc');\n\t}\n\n\t// Check if title meta data is available\n\tif (('title' in this.meta) && _.isString(this.meta.title) && this.meta.title.length) {\n\t\tif (!this.title) {\n\t\t\tthis.title\t\t\t\t\t= this.dom.documentElement.insertBefore(this.dom.createElementNS(this.DEFAULT_SVG_NAMESPACE, 'title'), this.dom.documentElement.firstChild);\n\t\t}\n\t\tthis.title.textContent\t\t\t= this.meta.title;\n\t\tthis.title.setAttribute('id', this.id + '-title');\n\t\tariaLabelledBy.push(this.id + '-title');\n\t}\n\n\tif (ariaLabelledBy.length) {\n\t\tthis.dom.documentElement.setAttribute('aria-labelledby', ariaLabelledBy.join(' '));\n\t} else if (this.dom.documentElement.hasAttribute('aria-labelledby')) {\n\t\tthis.dom.documentElement.removeAttribute('aria-labelledby');\n\t}\n\n\tcb(null);\n};\n\n/**\n * Apply a namespace prefix to all IDs within the SVG document\n *\n * @param {String} ns\t\t\t\tID namespace\n */\nSVGShape.prototype.setNamespace = function(ns) {\n\tvar namespaceIds                   = !!this.spriter.config.svg.namespaceIDs;\n\tvar namespaceClassnames            = !!this.spriter.config.svg.namespaceClassnames;\n\tif (!this._namespaced && (namespaceIds || namespaceClassnames)) {\n\n\t\t// Ensure the shape has been complemented before\n\t\tif (!this.svg.ready) {\n\t\t\tvar error\t\t\t\t   = new Error('Shape namespace cannot be set before complementing');\n\t\t\terror.name\t\t\t\t   = 'NotPermittedError';\n\t\t\terror.errno\t\t\t\t   = 1419162245;\n\t\t\tthrow error;\n\t\t}\n\n\t\tvar select\t\t\t\t\t   = xpath.useNamespaces({'svg': this.DEFAULT_SVG_NAMESPACE, 'xlink': this.XLINK_NAMESPACE});\n\t\tvar substIds                   = null;\n\t\tvar substClassnames            = null;\n\n\t\t// If IDs should be namespaced\n\t\tif (namespaceIds) {\n\n    \t\t// Build an ID substitution table (and alter the elements' IDs accordingly)\n    \t\tsubstIds\t\t\t\t    = {};\n    \t\tselect('//*[@id]', this.dom).forEach(function(elem) {\n    \t\t\tvar id\t\t\t\t\t= elem.getAttribute('id'),\n    \t\t\tsubstId\t\t\t\t\t= ns + id;\n    \t\t\tsubstIds['#' + id]\t\t= substId;\n    \t\t\telem.setAttribute('id', substId);\n    \t\t});\n\n    \t\t// Substitute ID references in xlink:href attributes\n    \t\tselect('//@xlink:href', this.dom).forEach(function(xlink){\n    \t\t\tvar xlinkValue\t\t\t= xlink.nodeValue;\n    \t\t\tif ((xlinkValue.indexOf('data:') !== 0) && (xlinkValue in substIds)) {\n    \t\t\t\txlink.ownerElement.setAttribute('xlink:href', '#' + substIds[xlinkValue]);\n    \t\t\t}\n    \t\t});\n\n    \t\t// Substitute ID references in referencing attributes\n    \t\tsvgReferenceProperties.forEach(function(refProperty){\n    \t\t\tselect('//@' + refProperty, this.dom).forEach(function(ref) {\n    \t\t\t\tref.ownerElement.setAttribute(ref.localName, this._replaceIdAndClassnameReferences(ref.nodeValue, substIds, substClassnames, false));\n    \t\t\t}, this);\n    \t\t}, this);\n\n    \t\t// Substitute ID references in aria-labelledby attribute\n    \t\tif (this.dom.documentElement.hasAttribute('aria-labelledby')) {\n    \t\t\tthis.dom.documentElement.setAttribute('aria-labelledby', this.dom.documentElement.getAttribute('aria-labelledby').split(' ').map(function(label){\n    \t\t\t\treturn (('#' + label) in substIds) ? substIds['#' + label] : label;\n    \t\t\t}).join(' '));\n    \t\t}\n\t\t}\n\n\t\t// If CSS class names should be namespaced\n\t\tif (namespaceClassnames) {\n\n\t\t\t// Build a class name substitution table (and alter the elements' class names accordingly)\n\t\t\tsubstClassnames             = {};\n            select('//*[@class]', this.dom).forEach(function(elem) {\n            \tvar elemClassnames      = [];\n                elem.getAttribute('class').split(' ').filter(function(classname){\n                    return classname.trim();\n                }).forEach(function(classname){\n                    var substClassname  = ns + classname;\n                    substClassnames['.' + classname]      = substClassname;\n                    elemClassnames.push(substClassname);\n                });\n                elem.setAttribute('class', elemClassnames.join(' '));\n            });\n\t\t}\n\n        // Substitute ID references in <style> elements\n        var style                       = select('//svg:style', this.dom);\n        if (style.length) {\n            var cssmin                  = require('cssmin');\n            select('//svg:style', this.dom).forEach(function(style) {\n                style.textContent       = cssmin(this._replaceIdAndClassnameReferences(style.textContent, substIds, substClassnames, true));\n            }, this);\n        }\n\n\t\tthis._namespaced\t\t\t    = true;\n\t}\n};\n\n/**\n * Reset the shapes namespace\n */\nSVGShape.prototype.resetNamespace = function() {\n\tif (this._namespaced && !!this.spriter.config.svg.namespaceIDs) {\n\t\tthis._namespaced\t\t= false;\n\t\tthis.dom\t\t\t\t= new DOMParser().parseFromString(this.svg.ready);\n\t}\n};\n\n/**\n * Replace ID references\n *\n * @param {String} str\t\t\t        String\n * @param {Object} substIds\t\t        ID substitutions\n * @param {Object} substClassnames\t\tClass name substitutions\n * @param {Boolean} selectors\t        Substitute CSS selectors\n * @return {String}\t\t\t\t        String with replaced ID and class name references\n */\nSVGShape.prototype._replaceIdAndClassnameReferences = function(str, substIds, substClassnames, selectors) {\n\n\t// If ID replacement is to be applied: Replace url()-style ID references\n\tif (substIds !== null) {\n    \tstr = str.replace(/url\\s*\\(\\s*[\"']?([^\\)]+)[\"']?\\s*\\)/g, function(match, id){\n    \t\treturn 'url(' + ((id in substIds) ? ('#' + substIds[id]) : id) + ')';\n    \t});\n\t}\n\n\treturn selectors ? this._replaceIdAndClassnameReferencesInCssSelectors(str, cssom.parse(str).cssRules, substIds, substClassnames) : str;\n};\n\n/**\n * Recursively replace ID references in CSS selectors\n *\n * @param {String} str\t\t\t        Original CSS text\n * @param {Array} rules\t\t\t        CSS rules\n * @param {Object} substIds             ID substitutions\n * @param {Object} substClassnames      Class name substitutions\n * @return {String}\t\t\t\t        Substituted CSS text\n */\nSVGShape.prototype._replaceIdAndClassnameReferencesInCssSelectors = function(str, rules, substIds, substClassnames) {\n\tvar css\t\t\t\t\t\t= '';\n\n\trules.forEach(function(rule) {\n\t\tvar selText\t\t\t    = rule.selectorText;\n\n\t\t// @-rule\n\t\tif (_.isUndefined(selText)) {\n\n\t\t\t// If there's a key text: Copy the CSS rule\n\t\t\tif (rule.keyText) {\n\t\t\t\tcss\t\t\t\t+= str.substr(rule.__starts, rule.__ends);\n\n\t\t\t// Else: Recursively process rule content\n\t\t\t} else if (_.isArray(rule.cssRules)) {\n\t\t\t\tcss\t\t\t\t+= str.substring(rule.__starts, rule.cssRules[0].__starts) + this._replaceIdAndClassnameReferencesInCssSelectors(str, rule.cssRules, substIds, substClassnames) + str.substring(rule.cssRules[rule.cssRules.length - 1].__ends, rule.__ends);\n\t\t\t}\n\n\t\t// Regular selector\n\t\t} else {\n\t\t\tvar origSelText\t\t= selText;\n\t\t\tvar sel\t\t\t\t= csssel.parse(selText);\n\t\t\tvar ids\t\t\t\t= [];\n\t\t\tvar classnames      = [];\n\t\t\tvar classnameFilter = function(classname){\n                if (('.' + classname) in substClassnames) {\n                    classnames.push(classname);\n                }\n            };\n\t\t\tvar idOrClassSubstitution = function(sel){\n\t\t\t\t// If ID substitution should be applied: Search for an ID\n\t\t\t\tif (('id' in sel.rule) && (substIds !== null) && (('#' + sel.rule.id) in substIds)) {\n\t\t\t\t\tids.push(sel.rule.id);\n\t\t\t\t}\n\n\t\t\t\t// If class name substitution should be applied: Search for class names\n\t\t\t\tif (('classNames' in sel.rule) && (substClassnames !== null) && _.isArray(sel.rule.classNames)) {\n\t\t\t\t\tsel.rule.classNames.forEach(classnameFilter);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// If there are multiple subselectors, substitute all of them\n\t\t\tif ('selectors' in sel) {\n\t\t\t\tsel.selectors.forEach(idOrClassSubstitution);\n\t\t\t}\n\n\t\t\t// While there are nested rules: Substitute and recurse\n\t\t\twhile ((typeof(sel) === 'object') && ('rule' in sel)) {\n\t\t\t\tidOrClassSubstitution(sel);\n\t\t\t\tsel\t\t\t\t= sel.rule;\n\t\t\t}\n\n\t\t\t// Substitute IDs within the selector\n\t\t\tif (ids.length) {\n\t\t\t\tids.sort(function(a, b){\n\t\t\t\t\treturn b.length - a.length;\n\t\t\t\t});\n\t\t\t\tids.forEach(function(id) {\n\t\t\t\t\tselText\t\t= selText.split('#' + id).join('#' + substIds['#' + id]);\n\t\t\t\t}, this);\n\t\t\t}\n\n\t\t\t// Substitute class names within the selector\n\t\t\tif (classnames.length) {\n\t\t\t\tclassnames      = _.uniq(classnames);\n\t\t\t\tclassnames.sort(function(a, b){\n                    return b.length - a.length;\n                });\n                classnames.forEach(function(classname) {\n                    selText     = selText.split('.' + classname).join('.' + substClassnames['.' + classname]);\n                }, this);\n\t\t\t}\n\n\t\t\t// Rebuild the selector\n\t\t\tcss\t\t\t\t\t+= selText + str.substring(rule.__starts + origSelText.length, rule.__ends);\n\t\t}\n\t}, this);\n\n\treturn css;\n};\n\n/**\n * Create distribute to several copies (if configured)\n *\n * @return {Array}\t\t\t\tDisplaced copies\n */\nSVGShape.prototype.distribute = function() {\n\tvar copies\t\t\t\t\t= [],\n\talignments\t\t\t\t\t= this.align.slice(0),\n\talign\t\t\t\t\t\t= alignments.shift(),\n\tbase\t\t\t\t\t\t= this.base;\n\tthis.base\t\t\t\t\t= util.format(align[0], this.base);\n\tthis.id\t\t\t\t\t\t= this.base + (this.state ? (this.config.id.pseudo + this.state) : '');\n\tthis.align\t\t\t\t\t= align[1];\n\tcopies.push(this);\n\n\t// Run through all remaining alignments\n\talignments.forEach(function(alignment){\n\t\tvar copy\t\t\t\t= _.merge(new SVGShape(this.source, this.spriter), this);\n\t\tcopy.base\t\t\t\t= util.format(alignment[0], base);\n\t\tcopy.id\t\t\t\t\t= copy.base + (this.state ? (this.config.id.pseudo + this.state) : '');\n\t\tcopy.align\t\t\t\t= alignment[1];\n\t\tcopy.master\t\t\t\t= this;\n\t\tcopies.push(copy);\n\t}, this);\n\n\tthis.copies\t\t\t\t\t= alignments.length;\n\treturn copies;\n};\n\n/**\n * Module export (constructor wrapper)\n *\n * @param {String} svg\t\t\tSVG content\n * @param {String} name\t\t\tName part or the file path\n * @param {String} file\t\t\tAbsolute file path\n * @param {Object} config\t\tSVG shape configuration\n * @return {SVGShape}\t\t\tSVGShape instance\n */\nmodule.exports = function(svg, name, file, config) {\n\treturn new SVGShape(svg, name, file, config || {});\n};\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/transform/svgo.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2015 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar SVGO\t\t\t\t\t\t\t= require('svgo'),\n_\t\t\t\t\t\t\t\t\t= require('lodash'),\npretty\t\t\t\t\t\t\t\t= require('prettysize'),\ndefaultPluginConfig\t\t\t\t\t= [\n//\t{cleanupAttrs\t\t\t\t\t: true}, // cleanup attributes from newlines, trailing and repeating spaces\n//\t{removeDoctype\t\t\t\t\t: true}, // remove doctype declaration\n//\t{removeXMLProcInst\t\t\t\t: true}, // remove XML processing instructions\n//\t{removeComments\t\t\t\t\t: true}, // remove comments\n//\t{removeMetadata\t\t\t\t\t: true}, // remove `<metadata>`\n//\t{removeTitle\t\t\t\t\t: true}, // remove `<title>`\n//\t{removeEditorsNSData\t\t\t: true}, // remove editors namespaces, elements and attributes\n//\t{removeEmptyAttrs\t\t\t\t: true}, // remove empty attributes\n//\t{removeHiddenElems\t\t\t\t: true}, // remove hidden elements\n//\t{removeEmptyText\t\t\t\t: true}, // remove empty Text elements\n//\t{removeEmptyContainers\t\t\t: true}, // remove empty Container elements\n\t{removeViewBox\t\t\t\t\t: false}, // remove `viewBox` attribute when possible\n//\t{cleanupEnableBackground\t\t: true}, // remove or cleanup `enable-background` attribute when possible\n//\t{convertStyleToAttrs\t\t\t: true}, // convert styles into attributes\n//\t{convertColors\t\t\t\t\t: true}, // convert colors (from `rgb()` to `#rrggbb`, from `#rrggbb` to `#rgb`)\n//\t{convertPathData\t\t\t\t: true}, // convert Path data to relative, convert one segment to another, trim useless delimiters and much more\n//\t{convertTransform\t\t\t\t: true}, // collapse multiple transforms into one, convert matrices to the short aliases and much more\n//\t{removeUnknownsAndDefaults\t\t: true}, // remove unknown elements content and attributes, remove attrs with default values\n//\t{removeNonInheritableGroupAttrs\t: true}, // remove non-inheritable group's \"presentation\" attributes\n//\t{removeUnusedNS\t\t\t\t\t: true}, // remove unused namespaces declaration\n//\t{cleanupIDs\t\t\t\t\t\t: true}, // remove unused and minify used IDs\n//\t{cleanupNumericValues\t\t\t: true}, // round numeric values to the fixed precision, remove default 'px' units\n//\t{moveElemsAttrsToGroup\t\t\t: true}, // move elements attributes to the existing group wrapper\n\t{moveGroupAttrsToElems\t\t\t: false} // move some group attributes to the content elements\n//\t{collapseGroups\t\t\t\t\t: true}, // collapse useless groups\n//\t{removeRasterImages\t\t\t\t: false}, // remove raster images (disabled by default)\n//\t{mergePaths\t\t\t\t\t\t: true}, // merge multiple Paths into one\n//\t{convertShapeToPath\t\t\t\t: true}, // convert some basic shapes to path\n//\t{transformsWithOnePath\t\t\t: true}, // apply transforms, crop by real width, center vertical alignment and resize SVG with one Path inside\n];\n\n/**\n * SVGO transformation\n *\n * @param {SVGShape} shape\t\t\t\tSVG shape\n * @param {Object} config\t\t\t\tTransform configuration\n * @param {SVGSpriter} spriter\t\t\tSpriter instance\n * @param {Function} cb\t\t\t\t\tCallback\n */\nmodule.exports = function(shape, config, spriter, cb) {\n\tconfig\t\t\t\t\t\t\t= _.cloneDeep(config);\n\tconfig.plugins\t\t\t\t\t= ('plugins' in config) ? defaultPluginConfig.concat(config.plugins) : defaultPluginConfig;\n\tconfig.plugins.push({removeXMLProcInst: !!spriter.config.svg.xmlDeclaration});\n\tconfig.plugins.push({removeDoctype: !!spriter.config.svg.doctypeDeclaration});\n\n\tvar svg\t\t\t\t\t\t\t= shape.getSVG(false),\n\tsvgLength\t\t\t\t\t\t= svg.length,\n\tsvgoInstance\t\t\t\t\t= new SVGO(config);\n\n\ttry {\n\t\tsvgoInstance.optimize(svg, function(result) {\n\t\t\tshape.setSVG(result.data);\n\n\t\t\tif (spriter.config.log.transports.console.level === 'debug') {\n\t\t\t\tvar optSVGLength\t= shape.getSVG(false).length;\n\t\t\t\tspriter.debug('Optimized \"%s\" with SVGO (saved %s / %s%%)', shape.name, pretty(svgLength - optSVGLength), Math.round(100 * (svgLength - optSVGLength) / svgLength));\n\t\t\t}\n\n\t\t\tcb(null);\n\t\t});\n\t} catch (error) {\n\t\tspriter.error('Optimizing \"%s\" with SVGO failed with error \"%s\"', shape.name, error);\n\t\tcb(error);\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-svg-sprite/node_modules/svg-sprite/lib/svg-sprite/layouter.js":"'use strict';\n\n/**\n * svg-sprite is a Node.js module for creating SVG sprites\n *\n * @see https://github.com/jkphl/svg-sprite\n *\n * @author Joschi Kuphal <joschi@kuphal.net> (https://github.com/jkphl)\n * @copyright © 2016 Joschi Kuphal\n * @license MIT https://raw.github.com/jkphl/svg-sprite/master/LICENSE\n */\n\nvar _                               = require('lodash'),\ndefaultConfig                       = {\n    css                             : {\n        dest                        : 'css',\n        layout                      : 'packed',\n        common                      : null,\n        mixin\t\t\t\t\t\t: null,\n        prefix                      : '.svg-%s',\n        dimensions                  : '-dims',\n        sprite                      : 'svg/sprite.css.svg',\n        bust\t\t\t\t\t\t: true\n    },\n    view                            : {\n        dest                        : 'view',\n        layout                      : 'packed',\n        common                      : null,\n        mixin\t\t\t\t\t\t: null,\n        prefix                      : '.svg-%s',\n        dimensions                  : '-dims',\n        sprite                      : 'svg/sprite.view.svg',\n        bust\t\t\t\t\t\t: true\n    },\n    defs                            : {\n        dest                        : 'defs',\n        prefix                      : '.svg-%s',\n        dimensions                  : '-dims',\n        sprite                      : 'svg/sprite.defs.svg',\n        inline\t\t\t\t\t\t: false,\n        example\t\t\t\t\t\t: false,\n        bust\t\t\t\t\t\t: false\n    },\n    symbol                          : {\n        dest                        : 'symbol',\n        prefix                      : '.svg-%s',\n        dimensions                  : '-dims',\n        sprite                      : 'svg/sprite.symbol.svg',\n        inline\t\t\t\t\t\t: false,\n        example\t\t\t\t\t\t: false,\n        bust\t\t\t\t\t\t: false\n    },\n    stack\t\t\t\t\t\t\t: {\n        dest                        : 'stack',\n        prefix                      : '.svg-%s',\n        dimensions                  : '-dims',\n        sprite                      : 'svg/sprite.stack.svg',\n        example\t\t\t\t\t\t: false,\n        bust\t\t\t\t\t\t: false\n    }\n},\ndefaultVariables                    = {\n    date                            : (new Date()).toGMTString(),\n    invert                          : function() {\n        return function(num, render) {\n            return -parseFloat(render(num), 10);\n        };\n    },\n    classname                       : function() {\n        return function(str, render) {\n        \tvar classname\t\t\t= render(str).replace(/\\s+/g, ' ').split(' ').pop();\n        \treturn (classname.indexOf('.') === 0) ? classname.substr(1) : classname;\n        };\n    },\n    escape                          : function() {\n        return function(str, render) {\n            return render(str).split('\\\\').join('\\\\\\\\');\n        };\n    }\n};\n\n/**\n * SVGSprite layouter\n *\n * @param {SVGSpriter} spriter\t\tSVG spriter\n * @param {Object} config\t\t\tLayout configuration\n */\nfunction SVGSpriteLayouter(spriter, config) {\n    this._spriter                   = spriter;\n    this.config                     = config;\n    this.mode                       = null;\n    this.files                      = {};\n    this.data                       = {};\n    this._commonData                = _.extend({shapes: []}, defaultVariables, this._spriter.config.variables);\n\n    // Register the common shapes data\n    this._spriter._shapes.forEach(function(shape, index) {\n        var dimensions              = shape.getDimensions(),\n        padding                     = shape.config.spacing.padding;\n\n        this._commonData.shapes.push({\n            name                    : shape.id,\n            base                    : shape.base,\n            master                  : shape.master ? shape.master.id : null,\n            width                   : {\n                inner               : dimensions.width - padding.right - padding.left,\n                outer               : dimensions.width\n            },\n            height                  : {\n                inner               : dimensions.height - padding.top - padding.bottom,\n                outer               : dimensions.height\n            },\n            first                   : !index,\n            last                    : (index === (this._spriter._shapes.length - 1))\n        });\n    }, this);\n\n    this._spriter.debug('Created layouter instance');\n}\n\n/**\n * Prototype\n *\n * @type {Object}\n */\nSVGSpriteLayouter.prototype = {};\n\n/**\n * Layout as a sprite\n *\n * @param {Object} files            Files\n * @param {String} key\t\t\t\tResult key\n * @param {String} mode\t\t\t\tMode\n * @param {Function} cb             Callback\n */\nSVGSpriteLayouter.prototype.layout = function(files, key, mode, cb) {\n\tthis._spriter.info('Laying out «%s» sprite («%s» mode)', key, mode);\n\tvar SVGSpriteLayout\t\t\t\t= require('./mode/' + mode),\n    config                          = _.merge(_.merge(_.clone(defaultConfig[mode], true), {svg: this._spriter.config.svg}), this.config[key] || {}),\n    data                            = _.merge(_.merge(_.merge({}, this._commonData), this._spriter.config.variables), config.variables),\n    sprite                          = new SVGSpriteLayout(this._spriter, config, data, key);\n    files[key]\t\t\t\t\t\t= {};\n    sprite.layout(files[key], cb);\n};\n\n/**\n * Module export (constructor wrapper)\n *\n * @param {SVGSpriter} spriter\t\tSVG spriter\n * @param {Object} config\t\t\tLayout configuration\n * @return {SVGSpriteLayouter}\t\tSVGSpriter Layouter\n */\nmodule.exports = SVGSpriteLayouter;\n"}